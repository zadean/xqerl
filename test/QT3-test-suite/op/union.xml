<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="op-union">
   <description>Tests for the union() function</description>
   <link type="spec" document="http://www.w3.org/TR/xpath-functions-30/"
         idref="func-union"/>
         
   <environment name="acme_corp">
      <source role="." file="union/acme_corp.xml">
         <description>Source document for Function Declaration tests</description>
         <created by="Ravindranath Chennoju" on="2000-01-01"/>
      </source>
   </environment>
   
   <environment name="bib2">
      <source role="." file="union/bib2.xml">
         <description>Bibliography example with extra comments and PIs.</description>
         <created by="spec-authors" on="2000-01-01"/>
      </source>
   </environment>


   <test-case name="fn-union-node-args-001">
      <description> arg: node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/bib/book[3]/title union /bib/book[1]/title</test>
      <result>
         <assert-xml><![CDATA[<title>TCP/IP Illustrated</title><title>Data on the Web</title>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-002">
      <description> arg: incorrect nodes </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>(/bib/book/title | /bib/book)/local-name()</test>
      <result>
         <assert-string-value>book title book title book title book title</assert-string-value>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-003">
      <description> arg: node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <modified by="Michael Kay" on="2017-01-04" change="avoid relying on XML serialization"/>
      <environment ref="bib2"/>
      <test>/bib/book[3]/title | root(fn:exactly-one(/bib/book[3]/title))</test>
      <result>
         <all-of>
            <assert>$result[1][self::document-node()][bib/book[1]/@year = "1994"]</assert>
            <assert>$result[2][self::title][.="Data on the Web"]</assert>
         </all-of>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-004">
      <description> arg: text node &amp; node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/bib/book[3]/title/text() union /bib/book[1]/title</test>
      <result>
         <assert-xml><![CDATA[<title>TCP/IP Illustrated</title>Data on the Web]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-005">
      <description> arg: processing-instruction node &amp; node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/processing-instruction() union /bib/book[2]/title</test>
      <result>
         <assert-xml><![CDATA[<?PI1 Processing Instruction 1?><title>Advanced Programming in the Unix environment</title><?PI2 Processing Instruction 2?>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-006">
      <description> arg: processing-instruction node &amp; node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/processing-instruction(PI1) union /bib/book[3]/title</test>
      <result>
         <assert-xml><![CDATA[<?PI1 Processing Instruction 1?><title>Data on the Web</title>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-007">
      <description> arg: comment node &amp; node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/comment() union /bib/book[1]/title</test>
      <result>
         <assert-xml><![CDATA[<!-- this file is a copy of bib.xml; just adds a few comments and PI nodes for testing --><!-- Comment 1 --><title>TCP/IP Illustrated</title><!-- Comment 2 -->]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-008">
      <description> arg: text node &amp; node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/bib/book[3]/title/text() | /bib/book[1]/title</test>
      <result>
         <assert-xml><![CDATA[<title>TCP/IP Illustrated</title>Data on the Web]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-009">
      <description> arg: processing-instruction node &amp; node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/processing-instruction() | /bib/book[2]/title</test>
      <result>
         <assert-xml><![CDATA[<?PI1 Processing Instruction 1?><title>Advanced Programming in the Unix environment</title><?PI2 Processing Instruction 2?>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-010">
      <description> arg: processing-instruction node &amp; node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/processing-instruction(PI1) | /bib/book[3]/title</test>
      <result>
         <assert-xml><![CDATA[<?PI1 Processing Instruction 1?><title>Data on the Web</title>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-011">
      <description> arg: comment node &amp; node </description>
      <created by="Pulkita Tyagi" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>/comment() | /bib/book[1]/title</test>
      <result>
         <assert-xml><![CDATA[<!-- this file is a copy of bib.xml; just adds a few comments and PI nodes for testing --><!-- Comment 1 --><title>TCP/IP Illustrated</title><!-- Comment 2 -->]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-012">
      <description> arg: node &amp; non existing node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>//author union //nonexisting</test>
      <result>
         <assert-xml><![CDATA[<author><last>Stevens</last><first>W.</first></author><author><last>Stevens</last><first>W.</first></author><author><last>Abiteboul</last><first>Serge</first></author><author><last>Buneman</last><first>Peter</first></author><author><last>Suciu</last><first>Dan</first></author>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-013">
      <description> arg: node &amp; empty sequence </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>//author | ()</test>
      <result>
         <assert-xml><![CDATA[<author><last>Stevens</last><first>W.</first></author><author><last>Stevens</last><first>W.</first></author><author><last>Abiteboul</last><first>Serge</first></author><author><last>Buneman</last><first>Peter</first></author><author><last>Suciu</last><first>Dan</first></author>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-014">
      <description> arg: empty sequence &amp; empty sequence </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <test>() | ()</test>
      <result>
         <any-of>
            <assert-string-value/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-015">
      <description> arg: node and node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="atomic"/>
      <test>(/atomic:root/atomic:integer) union (/atomic:root/atomic:integer)</test>
      <result>
         <assert-xml><![CDATA[<atomic:integer xmlns:foo="http://www.example.com/foo" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:atomic="http://www.w3.org/XQueryTest">12678967543233</atomic:integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-016">
      <description> arg: node &amp; node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="atomic"/>
      <test>(/atomic:root/atomic:integer) union (/atomic:root/atomic:integer)</test>
      <result>
         <assert-xml><![CDATA[<atomic:integer xmlns:foo="http://www.example.com/foo" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:atomic="http://www.w3.org/XQueryTest">12678967543233</atomic:integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-017">
      <description> arg: node &amp; node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="atomic"/>
      <test>(/atomic:root/atomic:integer) | (/atomic:root/atomic:string)</test>
      <result>
         <assert-xml><![CDATA[<atomic:string xmlns:atomic="http://www.w3.org/XQueryTest" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:foo="http://www.example.com/foo">A String Function</atomic:string><atomic:integer xmlns:atomic="http://www.w3.org/XQueryTest" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:foo="http://www.example.com/foo">12678967543233</atomic:integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-018">
      <description> arg: text node &amp; text node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="atomic"/>
      <test>(/atomic:root/atomic:duration/text()) | (/atomic:root/atomic:duration/text())</test>
      <result>
         <assert-string-value>P1Y2M3DT10H30M</assert-string-value>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-019">
      <description> arg: text node &amp; text node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="atomic"/>
      <test>(/atomic:root/atomic:date/text()) | (/atomic:root/atomic:date/text())</test>
      <result>
         <assert-string-value>2000-01-01+05:00</assert-string-value>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-020">
      <description> arg: text node &amp; text node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="atomic"/>
      <test>(/atomic:root/atomic:base64Binary/text()) | (/atomic:root/atomic:base64Binary/text())</test>
      <result>
         <assert-string-value>R0lGODlhcgGSALMAAAQCAEMmCZtuMFQxDS8b</assert-string-value>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-021">
      <description> arg: text node &amp; text node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="atomic"/>
      <test>(/atomic:root/atomic:QName/text()) | (/atomic:root/atomic:QName/text())</test>
      <result>
         <assert-string-value>foo:aQname</assert-string-value>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-022">
      <description> arg: text node &amp; text node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="atomic"/>
      <test>(/atomic:root/atomic:idrefs/text()) | (/atomic:root/atomic:idrefs/text())</test>
      <result>
         <assert-string-value>id1 id2</assert-string-value>
      </result>
   </test-case>

   <test-case name="fn-union-node-args-023">
      <description> arg: node &amp; node </description>
      <created by="Ravindranath Chennoju" on="2005-06-14"/>
      <environment ref="bib2"/>
      <test>string-join(for $node in ((//price/text()) , (//price/text())) union ((//price/text()) , (//price/text())) return $node, "|")</test>
      <result>
         <assert-string-value> 65.95|65.95| 39.95|129.95</assert-string-value>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-1">
      <description> Ensure nodes are deduplicated and sorted even though one of the operands is the empty sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[<r> { let $i := <e> <a/> <b/> </e> return ($i/b, $i/a, $i/b, $i/a) | () } </r>]]></test>
      <result>
         <assert-xml><![CDATA[<r><a/><b/></r>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-2">
      <description> Ensure nodes are deduplicated and sorted even though one of the operands is the empty sequence(#2). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[<r> { let $i := <e> <a/> <b/> </e> return () | ($i/b, $i/a, $i/b, $i/a) } </r>]]></test>
      <result>
         <assert-xml><![CDATA[<r><a/><b/></r>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-3">
      <description> Use 'comment' as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union comment))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-4">
      <description> Ensure node deduplication is done on the operands. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[let $i := <e> <a/> <b/> <c/> </e>/a , $t := $i/following-sibling::b return (($i union ($i, $i)), (($t, $t) union $t))]]></test>
      <result>
         <assert-xml><![CDATA[<a/><b/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-5">
      <description> Only nodes are allowed. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3) union (1, 2, 3)</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-6">
      <description> Use a node kind keyword, text, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union text))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-7">
      <description> Use a node kind keyword, node, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union node))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-8">
      <description> Use a node kind keyword, element, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union element))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-9">
      <description> Use a node kind keyword, attribute, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union attribute))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-10">
      <description> Use a node kind keyword, document-node, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union document-node))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-11">
      <description> Use a node kind keyword, comment, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union comment))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-12">
      <description> Use a node kind keyword, processing-instruction, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union processing-instruction))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-13">
      <description> Use a node kind keyword, item, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union item))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-14">
      <description> Use a node kind keyword, document, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union document))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-15">
      <description> Use a node kind keyword, if, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union if))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-16">
      <description> Use a node kind keyword, then, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union then))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-17">
      <description> Use a node kind keyword, mod, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union mod))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-18">
      <description> Use a node kind keyword, div, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union div))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-19">
      <description> Use a node kind keyword, empty-sequence, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union empty-sequence))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-20">
      <description> Use a node kind keyword, schema-attribute, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union schema-attribute))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-21">
      <description> Use a node kind keyword, schema-element, to test query parsing. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(author union schema-element))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-22">
      <description> Use a computed attribute constructor as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union attribute {"name"} {()}))]]></test>
      <result>
         <assert-false/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-23">
      <description> Use a computed attribute constructor as right operand(#2). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union attribute name {()}))]]></test>
      <result>
         <assert-false/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-24">
      <description> Use a computed attribute constructor as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union element {"name"} {()}))]]></test>
      <result>
         <any-of>
            <assert-false/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-25">
      <description> Use an element constructor as right operand(#2). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union element name {()}))]]></test>
      <result>
         <any-of>
            <assert-false/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-26">
      <description> Use a processing instruction constructor as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union processing-instruction {"name"} {()}))]]></test>
      <result>
         <assert-false/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-27">
      <description> Use a processing instruction constructor as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union processing-instruction name {}))]]></test>
      <result>
         <assert-false/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-28">
      <description> Use a comment constructor as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union comment {()}))]]></test>
      <result>
         <assert-false/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-29">
      <description> Use a text node constructor as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union text {()}))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-30">
      <description> Use a name test that resembles the descendant axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union descendant))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-31">
      <description> Use a name test that resembles the attribute axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union attribute))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-32">
      <description> Use a name test that resembles the self axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union self))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-33">
      <description> Use a name test that resembles the descendant-or-self axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union descendant-or-self))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-34">
      <description> Use a name test that resembles the following-sibling axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union following-sibling))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-35">
      <description> Use a name test that resembles the following axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union following))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-36">
      <description> Use a name test that resembles the preceding-sibling axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union preceding-sibling))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-37">
      <description> Use a name test that resembles the preceding axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union preceding))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-38">
      <description> Use a name test that resembles the parent axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union parent))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-39">
      <description> Use a name test that resembles the ancestor axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union ancestor))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-40">
      <description> Use a name test that resembles the ancestor axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union ancestor))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-41">
      <description> Use a name test that resembles the ancestor-or-self axis as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union ancestor-or-self))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-42">
      <description> Use 'declare as right operand. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e/>/(a union declare))]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-43">
      <description> Extract the boolean value from a union expression. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <environment ref="acme_corp"/>
      <test>boolean(//employee[location = "Denver"] union //employee[last()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-44">
      <description> Extract the boolean value from a union expression(different keyword). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <environment ref="acme_corp"/>
      <test>boolean(//employee[location = "Denver"] | //employee[last()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-45">
      <description> Explicitly sort the result of a union expression. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <environment ref="acme_corp"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[ <r> { //(employee[location = "Denver"] union //employee[last()])/./location } </r>]]></test>
      <result>
         <assert-xml><![CDATA[<r><location>Denver</location><location>Denver</location><location>Denver</location><location>Boston</location></r>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-46">
      <description> Ensure two sequential union operators can be parsed(|). </description>
      <created by="Frans Englich" on="2009-01-26"/>
      <test>1|2|3</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="K2-SeqUnion-47">
      <description> Ensure two sequential union operators can be parsed(union). </description>
      <created by="Frans Englich" on="2009-01-26"/>
      <test>1 union 2 union 3</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="combiningnodeseqhc1">
      <description> Simple combination of node sequences involving integers. uses "|" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[for $h in ( (<hours>0</hours>,<hours>1</hours>) | //hours) order by number($h) return $h]]></test>
      <result>
         <assert-xml><![CDATA[<hours>0</hours><hours>1</hours><hours>12</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc2">
      <description> Simple combination of node sequences involving integers. uses "union" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[for $h in ( (<hours>0</hours>,<hours>1</hours>) union (//hours)) order by number($h) return $h]]></test>
      <result>
         <assert-xml><![CDATA[<hours>0</hours><hours>1</hours><hours>12</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc3">
      <description> Simple combination of node sequences involving integers and repetition. uses "|" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[for $h in ( (<hours>0</hours>,<hours>40</hours>) | (//hours)) order by number($h) return $h]]></test>
      <result>
         <assert-xml><![CDATA[<hours>0</hours><hours>12</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc4">
      <description> Simple combination of node sequences involving integers and repetition. uses "union" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[for $h in ( (<hours>0</hours>,<hours>40</hours>) union (//hours)) order by number($h) return $h]]></test>
      <result>
         <assert-xml><![CDATA[<hours>0</hours><hours>12</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc5">
      <description> Simple combination of node sequences involving integers and the empty sequence. Uses "|" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <dependency type="spec" value="XQ10+"/>
      <test>for $h in ( () | (//hours)) order by number($h) return $h</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc6">
      <description> Simple combination of node sequences involving integers and the empty sequence. Uses "union" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <dependency type="spec" value="XQ10+"/>
      <test>for $h in ( () union (//hours)) order by number($h) return $h</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc7">
      <description> Simple combination of node sequences involving different children of xml data source. Uses "|" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <dependency type="spec" value="XQ10+"/>
      <test>for $h in ( (//hours[xs:integer(.) le 20]) | (//hours[xs:integer(.) gt 20])) order by number($h) return $h</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc8">
      <description> Simple combination of node sequences involving xml data source. Uses "union" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <dependency type="spec" value="XQ10+"/>
      <test>for $h in ( (//hours[xs:integer(.) le 20]) union (//hours[xs:integer(.) gt 20])) order by number($h) return $h</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc9">
      <description> Simple combination of node sequences involving multiple xml data sources. Uses "|" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works-and-staff"/>
      <dependency type="spec" value="XQ10+"/>
      <test>for $h in ( ($works//hours) | ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours><grade>13</grade><grade>13</grade><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="combiningnodeseqhc10">
      <description> Simple combination of node sequences involving multiple xml data sources. Uses "union" operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works-and-staff"/>
      <dependency type="spec" value="XQ10+"/>
      <test>for $h in ( ($works//hours) union ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours><grade>13</grade><grade>13</grade><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>20</hours><hours>40</hours><hours>40</hours><hours>40</hours><hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>
      
   <test-case name="cbcl-fn-union-001">
      <description> Tests various optimizations on op:union </description>
      <created by="Nick Jones" on="2008-08-19"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        declare variable $x := <b/>;
        declare variable $y := <a/>;
        ($x union $y) union $x, ($x intersect $y) union $x, ($x except $y) union $x, ($y except $x) union $x, $x union ($x union $y), $x union ($x intersect $y), $x union ($x except $y), $x union ($y except $x)]]></test>
      <result>
         <any-of>
            <assert-xml><![CDATA[<b/><a/><b/><b/><b/><a/><b/><a/><b/><b/><b/><a/>]]></assert-xml>
            <assert-xml><![CDATA[<a/><b/><b/><b/><a/><b/><a/><b/><b/><b/><a/><b/>]]></assert-xml>
         </any-of>
      </result>
   </test-case>

   <test-case name="cbcl-fn-union-002">
      <description> Tests optimization of union of path expressions </description>
      <created by="Nick Jones" on="2008-08-19"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        declare variable $doc := <root><test><x/><y/></test></root>;
        $doc/test[x] union $doc/test[y]]]></test>
      <result>
         <assert-xml><![CDATA[<test><x/><y/></test>]]></assert-xml>
      </result>
   </test-case>


   
</test-set>