<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="prod-Predicate">
   <description>Tests for the Predicate production</description>
   <link type="spec" document="http://www.w3.org/TR/xquery-30/"
         idref="doc-xquery30-Predicate"/>
   <link type="spec" document="XQuery" section-number="3.3.2" idref="id-filter-expr"/>
   
   <environment name="atomicns">
      <source role="." file="../docs/atomicns.xml">
         <description>A non schema validated xml file, that contains values for data types. Can be used by any test.</description>
         <created by="Carmelo Montanez" on="2006-03-15"/>
      </source>
   </environment>

   <test-case name="filterexpressionhc1">
      <description> Filter Expression. Simple Filter expression involving numeric data and (gt operator0) </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <test>(/works/employee[xs:integer(hours[1]) gt 20])</test>
      <result>
         <assert-xml><![CDATA[<employee>
   <empnum>E1</empnum>
   <pnum>P1</pnum>
   <hours>40</hours>
  </employee><employee>
   <empnum>E1</empnum>
   <pnum>P3</pnum>
   <hours>80</hours>
  </employee><employee>
   <empnum>E2</empnum>
   <pnum>P1</pnum>
   <hours>40</hours>
  </employee><employee>
   <empnum>E2</empnum>
   <pnum>P2</pnum>
   <hours>80</hours>
  </employee><employee>
   <empnum>E4</empnum>
   <pnum>P4</pnum>
   <hours>40</hours>
  </employee><employee>
   <empnum>E4</empnum>
   <pnum>P5</pnum>
   <hours>80</hours>
  </employee>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="filterexpressionhc2">
      <description> Simple filter expression involving integers. Return integer from 1 to 25 divisible by 2 </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <test>((1 to 25)[. mod 2 eq 0])</test>
      <result>
         <assert-string-value>2 4 6 8 10 12 14 16 18 20 22 24</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc3">
      <description> Simple filter expression that returns a sigle number </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <test>((1 to 25)[25])</test>
      <result>
         <assert-eq>25</assert-eq>
      </result>
   </test-case>

   <test-case name="filterexpressionhc4">
      <description> Simple filter expression involving union operator </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <test>(//empnum | (/))//employee[xs:integer(hours[1]) gt 20]</test>
      <result>
         <assert-xml><![CDATA[<employee>
   <empnum>E1</empnum>
   <pnum>P1</pnum>
   <hours>40</hours>
  </employee><employee>
   <empnum>E1</empnum>
   <pnum>P3</pnum>
   <hours>80</hours>
  </employee><employee>
   <empnum>E2</empnum>
   <pnum>P1</pnum>
   <hours>40</hours>
  </employee><employee>
   <empnum>E2</empnum>
   <pnum>P2</pnum>
   <hours>80</hours>
  </employee><employee>
   <empnum>E4</empnum>
   <pnum>P4</pnum>
   <hours>40</hours>
  </employee><employee>
   <empnum>E4</empnum>
   <pnum>P5</pnum>
   <hours>80</hours>
  </employee>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="filterexpressionhc5">
      <description> Simple filter expression as a stept in a path expression involving the "last" function </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <environment ref="works"/>
      <test>(//employee[fn:last()])</test>
      <result>
         <assert-xml><![CDATA[<employee>
   <empnum>E4</empnum>
   <pnum>P5</pnum>
   <hours>80</hours>
  </employee>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="filterexpressionhc6">
      <description> Simple filter expression involving the ge operator </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1 to 25)[. ge 10])</test>
      <result>
         <assert-string-value>10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc7">
      <description> Simple filter expression involving the lt opertor </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1 to 25)[. lt 10])</test>
      <result>
         <assert-string-value>1 2 3 4 5 6 7 8 9</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc8">
      <description> Simple filter expression involving the le operator </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1 to 25)[. le 10])</test>
      <result>
         <assert-string-value>1 2 3 4 5 6 7 8 9 10</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc9">
      <description> Simple filter expression involving the eq operator </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1 to 25)[. eq 10])</test>
      <result>
         <assert-eq>10</assert-eq>
      </result>
   </test-case>

   <test-case name="filterexpressionhc10">
      <description> Simple filter expression involving the ne operator </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1 to 11)[. ne 10])</test>
      <result>
         <assert-string-value>1 2 3 4 5 6 7 8 9 11</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc11">
      <description> Simple filter expression involving a boolean "and" expression </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1 to 11)[(. eq 10) and (. mod 5 eq 0)])</test>
      <result>
         <assert-eq>10</assert-eq>
      </result>
   </test-case>

   <test-case name="filterexpressionhc12">
      <description> Simple filter expression involving a boolean "or" expression </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1 to 11)[(. eq 10) or (. eq 5)])</test>
      <result>
         <assert-string-value>5 10</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc13">
      <description> Simple filter expression involving a division expression </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,4,5,6,7,8,9,10,11)[(. div 2 eq 5)])</test>
      <result>
         <assert-eq>10</assert-eq>
      </result>
   </test-case>

   <test-case name="filterexpressionhc14">
      <description> Simple filter expression involving a multiplication expression </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,4,5,6,7,8,9,10,11)[(. * 2 eq 10)])</test>
      <result>
         <assert-eq>5</assert-eq>
      </result>
   </test-case>

   <test-case name="filterexpressionhc15">
      <description> Simple filter expression involving an addition expression </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,4,5,6,7,8,9,10,11)[(. + 2 eq 10)])</test>
      <result>
         <assert-eq>8</assert-eq>
      </result>
   </test-case>

   <test-case name="filterexpressionhc16">
      <description> Simple filter expression involving a subtration expression </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,4,5,6,7,8,9,10,11)[(. - 2 eq 6)])</test>
      <result>
         <assert-eq>8</assert-eq>
      </result>
   </test-case>

   <test-case name="filterexpressionhc17">
      <description> Simple filter expression involving an integer division (idiv) expression </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,4,5,6,7,8,9,10,11)[(. idiv 2 eq 3)])</test>
      <result>
         <assert-string-value>6 7</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc18">
      <description> Simple filter expression using an xs:string function </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,3,4,5,6,7,8,9,10,11)[(xs:string(.) eq "3")])</test>
      <result>
         <assert-eq>3</assert-eq>
      </result>
   </test-case>

   <test-case name="filterexpressionhc19">
      <description> Simple filter expression involving two simple predicates </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,3,4,5,6,7,8,9,10,11)[. gt 1][. gt 5])</test>
      <result>
         <assert-string-value>6 7 8 9 10 11</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc20">
      <description> Simple filter expression involving two complex predicates </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,3,4,5,6,7,8,9,10,11)[(. gt 1) and (. gt 2)][(. gt 5) and (. gt 6)])</test>
      <result>
         <assert-string-value>7 8 9 10 11</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc21">
      <description> Simple filter expression involving the "fn:true" function </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>((1,2,3,4,5,6,7,8,9,10,11)[fn:true()])</test>
      <result>
         <assert-string-value>1 2 3 4 5 6 7 8 9 10 11</assert-string-value>
      </result>
   </test-case>

   <test-case name="filterexpressionhc22">
      <description> Simple filter expression involving the "fn:false" function Use fn;count to avoid empty sequence. </description>
      <created by="Carmelo Montanez" on="2005-08-16"/>
      <test>fn:count(((1,2,3,4,5,6,7,8,9,10,11)[fn:false()]))</test>
      <result>
         <any-of>
            <assert-eq>0</assert-eq>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-1">
      <description> Syntactically invalid predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-2">
      <description> Syntactically invalid predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)]</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-3">
      <description> Syntactically invalid predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[]</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-4">
      <description> Syntactically invalid predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2014-10-08" change="test does not apply to 3.1"/>
      <dependency type="spec" value="XP20 XP30 XQ10 XQ30"/>
      <test>[true()]</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-5">
      <description> Syntactically invalid predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2014-10-08" change="test does not apply to 3.1"/>
      <dependency type="spec" value="XP20 XP30 XQ10 XQ30"/>
      <test>[]</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-6">
      <description> A test whose essence is: `empty((1, 2, 3)[0])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[0])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-7">
      <description> A test whose essence is: `empty((1, 2, 3)[4])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[4])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-8">
      <description> A test whose essence is: `empty((1, 2, 3)[0])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[0])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-9">
      <description> A test whose essence is: `empty((1, 2, 3)[4])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[4])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-10">
      <description> A test whose essence is: `empty((1, 2, 3)[0.1])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[0.1])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-11">
      <description> A test whose essence is: `empty((1, 2, 3)[1.1])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[1.1])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-12">
      <description> A test whose essence is: `empty((1, 2, 3)[1.01])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[1.01])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-13">
      <description> A test whose essence is: `empty((1, 2, 3)[4])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[4])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-14">
      <description> A test whose essence is: `empty((1, 2, 3)[4.1])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[4.1])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-15">
      <description> A test whose essence is: `empty((1, 2, 3)[4.01])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[4.01])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-16">
      <description> A test whose essence is: `not(empty((1, 2, 3)[1]))`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>not(empty((1, 2, 3)[1]))</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-17">
      <description> A test whose essence is: `not(empty((1, 2, 3)[3]))`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>not(empty((1, 2, 3)[3]))</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-18">
      <description> A test whose essence is: `(1, 2, 3)[1] eq 1`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[1] eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-19">
      <description> A test whose essence is: `(1, 2, 3)[1.0] eq 1`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[1.0] eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-20">
      <description> A test whose essence is: `(1, 2, 3)[1.0e0] eq 1`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[1.0e0] eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-21">
      <description> A test whose essence is: `(1, 2, 3)[3] eq 3`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[3] eq 3</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-22">
      <description> A test whose essence is: `(1, 2, 3)[3.0] eq 3`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[3.0] eq 3</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-23">
      <description> A test whose essence is: `(1, 2, 3)[3.0e0] eq 3`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[3.0e0] eq 3</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-24">
      <description> A test whose essence is: `(0, 1, 2)[1] eq 0`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[1] eq 0</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-25">
      <description> A test whose essence is: `(0, 1, 2)[2] eq 1`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[2] eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-26">
      <description> A test whose essence is: `(0, 1, 2)[3] eq 2`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[3] eq 2</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-27">
      <description> A test whose essence is: `(0)[1] eq 0`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0)[1] eq 0</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-28">
      <description> A test whose essence is: `0[1] eq 0`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>0[1] eq 0</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-29">
      <description> A test whose essence is: `(0, 1)[1] eq 0`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1)[1] eq 0</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-30">
      <description> A test whose essence is: `empty((1, 2, 3)[false()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[false()])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-31">
      <description> A test whose essence is: `deep-equal((1, 2, 3), (1, 2, 3)[true()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[true()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-32">
      <description> A test whose essence is: `deep-equal((1, 2, 3), (1, 2, 3)[. instance of xs:integer])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[. instance of xs:integer])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-33">
      <description> The context item is used as the predicate, leading to a truth predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((true(), true(), true()), (false(), true(), true(), false(), true(), false())[.])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-34">
      <description> The context item is used as the predicate, leading to a numeric predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((2, 3, 4, 5, 7, 8, 9), (0, 2, 3, 4, 5, 5, 7, 8, 10 - 1)[.])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-35">
      <description> Source expression of a predicate doesn't have to use paranteses. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>1[true()] eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-36">
      <description> Use fn:current-time() inside a predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, current-time())[1]</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-37">
      <description> One xs:anyURI value is a valid predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[xs:anyURI("example.com/")])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-38">
      <description> xs:anyURI values are invalid predicates. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[(xs:anyURI("example.com/"), xs:anyURI("example.com/"))]</test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-39">
      <description> xs:untypedAtomic literal as predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[xs:untypedAtomic("content")])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-40">
      <description> Multiple xs:untypedAtomic values is an invalid predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[(xs:untypedAtomic("content"), xs:untypedAtomic("content"))]</test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-41">
      <description> A test whose essence is: `(0, 1, 2)[true()][1] eq 0`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[true()][1] eq 0</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-42">
      <description> A test whose essence is: `(1, 2, 3)[position() eq 2 or position() eq 3][2] eq 3`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[position() eq 2 or position() eq 3][2] eq 3</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-43">
      <description> A test whose essence is: `empty((1, 2, 3)[position() eq 2 or position() eq 3][3])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[position() eq 2 or position() eq 3][3])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-44">
      <description> A test whose essence is: `deep-equal((1, 2, 3), (1, 2, 3)[2 or 3])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[2 or 3])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-45">
      <description> A test whose essence is: `empty((1, 2, 3)[3][2])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[3][2])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-46">
      <description> A test whose essence is: `empty((1, 2, 3)[3][0])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[3][0])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-47">
      <description> An excessive nesting of various predicates. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 2, 4, 5)[1][1][1][true()][1][true()][1] eq 0</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-48">
      <description> A large numeric xs:double predicate that evaluates to the empty sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[3e8])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-49">
      <description> A test whose essence is: `empty((0, 1, 2)[false()][1])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((0, 1, 2)[false()][1])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-50">
      <description> A test whose essence is: `deep-equal(("a", "b", "c"), (0, 1, 2, "a", "b", "c")[. instance of xs:string])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal(("a", "b", "c"), (0, 1, 2, "a", "b", "c")[. instance of xs:string])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-51">
      <description> Filter a sequence with instance of and a second predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>((0, 1, 2, "a", "b", "c")[. instance of xs:string][. treat as xs:string eq "c"] treat as xs:string) eq "c"</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPDY0050"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-52">
      <description> Filter a sequence with instance of and a second predicate(#2). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. treat as xs:integer eq 0] treat as xs:integer) eq 0</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPDY0050"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-53">
      <description> Two predicates, where one leading to an invalid operator mapping in the second. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2, "a", "b", "c")[. instance of xs:integer][. eq "c"] eq 0</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-54">
      <description> Predicates in combination with the empty sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty(()[()])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-55">
      <description> Predicates in combination with the empty sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[()])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-56">
      <description> Predicates in combination with the empty sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty(()[last()])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-57">
      <description> Predicates in combination with the empty sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty(()[1])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-58">
      <description> Predicates in combination with the empty sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty(()[position()])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-59">
      <description> Predicates in combination with the empty sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty(()[count(remove((current-time(), 1), 1)) eq 1])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-60">
      <description> A test whose essence is: `deep-equal((1, 2, 3), (1, 2, 3)[position() &gt;= 1])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[position() &gt;= 1])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-61">
      <description> A test whose essence is: `deep-equal((1, 2, 3), (1, 2, 3)[3 &gt;= position()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[3 &gt;= position()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-62">
      <description> A test whose essence is: `deep-equal((1, 2, 3), (1, 2, 3)[position() ge 1])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[position() ge 1])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-63">
      <description> A test whose essence is: `deep-equal((1, 2, 3), (1, 2, 3)[3 ge position()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[3 ge position()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-64">
      <description> A test whose essence is: `deep-equal((0, 1, 2), (0, 1, 2)[position() eq position()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((0, 1, 2), (0, 1, 2)[position() eq position()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-65">
      <description> A test whose essence is: `deep-equal((0, 1, 2), (0, 1, 2)[position() = position()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((0, 1, 2), (0, 1, 2)[position() = position()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-66">
      <description> A test whose essence is: `(0, 1, 2)[1 eq position()]`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[1 eq position()]</test>
      <result>
         <assert-eq>0</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-67">
      <description> A test whose essence is: `(0, 1, 2)[3 eq position()]`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[3 eq position()]</test>
      <result>
         <assert-eq>2</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-68">
      <description> A test whose essence is: `(0, 1, 2)[position() eq 3]`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[position() eq 3]</test>
      <result>
         <assert-eq>2</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-69">
      <description> A test whose essence is: `deep-equal((1, 2, 3), (1, 2, 3)[number(.)])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2, 3), (1, 2, 3)[number(.)])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-70">
      <description> A test whose essence is: `deep-equal((1, 2), (0, 1, 2)[if(. eq 1) then 2 else 3])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2), (0, 1, 2)[if(. eq 1) then 2 else 3])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-71">
      <description> A test whose essence is: `deep-equal((0, 1, 2), (0, 1, 2)[if(. eq 8) then "str" else position()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((0, 1, 2), (0, 1, 2)[if(. eq 8) then "str" else position()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-72">
      <description> A test whose essence is: `deep-equal((0, 1, 2), (0, 1, 2)[if(. eq 8) then 0 else position()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((0, 1, 2), (0, 1, 2)[if(. eq 8) then 0 else position()])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-73">
      <description> A test whose essence is: `(0, 1, 2)[last()]`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[last()]</test>
      <result>
         <assert-eq>2</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-74">
      <description> A test whose essence is: `(0, 1, "2")[last()]`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, "2")[last()]</test>
      <result>
         <assert-string-value>2</assert-string-value>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-75">
      <description> fn:last() in predicate, leading to invalid operator mapping. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>2 eq (0, 1, "2")[last()]</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-76">
      <description> A test whose essence is: `empty((())[last()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((())[last()])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-77">
      <description> A test whose essence is: `empty(()[last()])`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty(()[last()])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-78">
      <description> Predicates involving the focus' context item. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[. eq 0]</test>
      <result>
         <assert-eq>0</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-79">
      <description> Predicates involving the focus' context item. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[. eq 1]</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-80">
      <description> Predicates involving the focus' context item. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[. eq 2]</test>
      <result>
         <assert-eq>2</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-81">
      <description> Predicates involving the focus' context item. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((0, 1, 2), (0, 1, 2)[. eq 0 or . eq 1 or . eq 2])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-82">
      <description> Type related predicate tests. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(0, 1, 2)[remove((1, "a string"), 2)]</test>
      <result>
         <any-of>
            <assert-eq>0</assert-eq>
            <error code="XPTY0004"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-83">
      <description> Type related predicate tests. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal((1, 2), (1, 2)[remove((true(), "a string"), 2)])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPTY0004"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-84">
      <description> Type related predicate tests. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[remove((false(), "a string"), 2)])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPTY0004"/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-85">
      <description> Type related predicate tests. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3)[remove((false(), "a string"), 2)])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPTY0004"/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-86">
      <description> A predicate that never can match. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty(current-time()[2])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-87">
      <description> A predicate that never can match. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1, 2, 3, current-time())[0])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-88">
      <description> A truth predicate that never match. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty(remove((1, 2, 3, current-time()), 4)[false()])</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-89">
      <description> A truth predicate that always match. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>deep-equal(remove((1, 2, 3, current-time()), 4)[true()], (1, 2, 3))</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-90">
      <description> Nested predicate with multiple calls to fn:last(). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[(last(), last())[2]]</test>
      <result>
         <assert-eq>3</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-91">
      <description> A predicate whose expression EBV cannot be extracted from. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[xs:hexBinary("FF")]</test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-92">
      <description> A predicate whose expression EBV cannot be extracted from. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[1, 2]</test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-93">
      <description> A predicate whose expression EBV cannot be extracted from. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)[1, "a string"]</test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>

   <test-case name="K-FilterExpr-94">
      <description> A predicate whose expression EBV cannot be extracted from. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(1, 2, 3)["a string", 1]</test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>
   
   <test-case name="K-FilterExpr-95">
      <description> Filter expression where the predicate depends only on the context document (optimization potential). </description>
      <created by="Michael Kay" on="2016-06-23"/>
      <environment ref="works-mod"/>
      <test>/works/employee[@name=/works/employee[1]/@name]/@name/string()</test>
      <result>
         <assert-eq>"Jane Doe 1"</assert-eq>
      </result>
   </test-case>
   
   <test-case name="K-FilterExpr-96">
      <description> Filter expression where the predicate depends only on the context document (optimization pitfall). </description>
      <created by="Michael Kay" on="2016-06-23"/>
      <environment ref="works-mod"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
         document{<works>{/tail(works/employee)}</works>}/works/employee[@name=/works/employee[2]/@name]/@name/string()
         ]]></test>
      <result>
         <assert-eq>"Jane Doe 3"</assert-eq>
      </result>
   </test-case>

   <test-case name="K2-FilterExpr-1">
      <description> Apply a predicate combined with last(), on a sequence constructed with an element constructor. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[declare variable $var := (for $i in 1 to 100 return <e>{$i}</e>); $var[last()]]]></test>
      <result>
         <assert-xml><![CDATA[<e>100</e>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-FilterExpr-2">
      <description> Apply a predicate combined with a numeric literal, on a sequence constructed with an element constructor. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[declare variable $var := (for $i in 1 to 100 return <e>{$i}</e>); $var[5]]]></test>
      <result>
         <assert-xml><![CDATA[<e>5</e>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-FilterExpr-3">
      <description> An numeric predicate that is xs:decimal. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>empty((1,2,3,4,5)[3.4])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-FilterExpr-4">
      <description> An numeric predicate that is xs:decimal, as part of a path expression. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[empty(<e><a/></e>//a[3.4])]]></test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K2-FilterExpr-5">
      <description> Subsequent filter expressions, and node tests whose focus depends on where a variable is declared. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2017-03-17" change="avoid reliance on implicit XML tree construction"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
         let $d := document {<root><child type=""/></root>} 
         return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}
       ]]></test>
      <result>
         <any-of>
            <assert-xml><![CDATA[<child type=""/>1 2 3]]></assert-xml>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K2-FilterExpr-6">
      <description> Subsequent filter expressions, and node tests whose focus depends on where a variable is declared(#2). </description>
      <created by="Frans Englich" on="2008-01-15"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[let $d := document { <root><child type=""/></root> } return $d//*[let $i := @type return $d//*[$i]]]]></test>
      <result>
         <assert-xml><![CDATA[<child type=""/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-FilterExpr-7">
      <description> Use self::processing-instruction() in a filter predicate. </description>
      <created by="Frans Englich" on="2008-01-15"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[(<x/>, <?y?>)[self::processing-instruction()]]]></test>
      <result>
         <assert-xml><![CDATA[<?y?>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-FilterExpr-8">
      <description> Use self::processing-instruction() in a filter predicate, combined with a treat as. </description>
      <created by="Frans Englich" on="2008-01-15"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[(<?z?>, <?y?>)[self::processing-instruction(y)] treat as empty-sequence()]]></test>
      <result>
         <error code="XPDY0050"/>
      </result>
   </test-case>
   
      <test-case name="predicates-1">
      <description> Evaluation of a simple predicate with a "true" value (uses "fn:true"). </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(//integer[fn:true()])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-2">
      <description> Evaluation of a simple predicate with a "false" value (uses "fn:false"). Use of fn:count to avoid empty file. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>fn:count((//integer[fn:false()]))</test>
      <result>
         <any-of>
            <assert-eq>0</assert-eq>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="predicates-3">
      <description> Evaluation of a simple predicate with a "true" value (uses "fn:false" and fn:not()). </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(//integer[fn:not(fn:false())])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-4">
      <description> Evaluation of a simple predicate set to a boolean expression ("and" operator). </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(//integer[fn:true() and fn:true()])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-5">
      <description> Evaluation of a simple predicate set to a boolean expression ("or" operator). </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(//integer[fn:true() or fn:true()])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-6">
      <description> Evaluation of a simple predicate set to a boolean expression ("and" operator). Returns "false" Uses "fn:count" to avoid empty file. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>fn:count((//integer[fn:false() and fn:false()]))</test>
      <result>
         <any-of>
            <assert-eq>0</assert-eq>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="predicates-7">
      <description> Evaluation of a simple predicate set to a boolean expression ("or" operator). Returns "false" Uses "fn:count" to avoid empty file. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>fn:count((//integer[fn:false() or fn:false()]))</test>
      <result>
         <any-of>
            <assert-eq>0</assert-eq>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="predicates-8">
      <description> Evaluation of a simple predicate, that uses the "xs:string()" function. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(/root/string[xs:string(.) = "A String Function"])</test>
      <result>
         <assert-xml><![CDATA[<string>A String Function</string>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-9">
      <description> Evaluation of a simple predicate, that uses the "xs:integer()" function. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(/root/integer[xs:integer(.) = 12678967543233])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-10">
      <description> Evaluation of a simple predicate, that uses the "xs:decimal()" function. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(/root/decimal[xs:decimal(.) = 12678967.543233])</test>
      <result>
         <assert-xml><![CDATA[<decimal attr="12678967.543233">12678967.543233</decimal>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-11">
      <description> Evaluation of a simple predicate, that uses the "xs:float()" function. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(/root/float[xs:float(.) = xs:float(1267.43233E12)])</test>
      <result>
         <assert-xml><![CDATA[<float>1267.43233E12</float>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-12">
      <description> Evaluation of a simple predicate, that uses the "xs:double()" function. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(/root/double[xs:double(.) = 1267.43233E12])</test>
      <result>
         <assert-xml><![CDATA[<double>1267.43233E12</double>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-13">
      <description> Evaluation of a simple predicate, that uses the "xs:boolean" function. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(/root/boolean[xs:boolean(.) = fn:true()])</test>
      <result>
         <assert-xml><![CDATA[<boolean>true</boolean>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-14">
      <description> Evaluation of a simple predicate, that uses the "xs:date()" function. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="atomicns"/>
      <test>(/root/date[xs:date(.) = xs:date("2000-01-01+05:00")])</test>
      <result>
         <assert-xml><![CDATA[<date>2000-01-01+05:00</date>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-17">
      <description> Evaluation of a simple predicate, that uses the "eq" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works/employee[@name="Jane Doe 11"])</test>
      <result>
         <assert-xml><![CDATA[<employee name="Jane Doe 11" gender="female">
   <empnum>E4</empnum>
   <pnum>P2</pnum>
   <hours>20</hours>
  </employee>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-18">
      <description> Evaluation of a simple predicate, that uses the "ne" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works//day[xs:string(.) ne "Monday"])</test>
      <result>
         <assert-xml><![CDATA[<day>Tuesday</day>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-19">
      <description> Evaluation of a simple predicate, that uses the "lt" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works//hours[xs:integer(.) lt 13])</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-20">
      <description> Evaluation of a simple predicate, that uses the "le" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works//hours[xs:integer(.) le 12])</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-21">
      <description> Evaluation of a simple predicate, that uses the "gt" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works//hours[xs:integer(.) gt 79])</test>
      <result>
         <assert-xml><![CDATA[<hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-22">
      <description> Evaluation of a simple predicate, that uses the "ge" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works//hours[xs:integer(.) ge 80])</test>
      <result>
         <assert-xml><![CDATA[<hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-23">
      <description> Evaluation of a simple predicate, that uses the "=" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works//hours[xs:integer(.) = 12])</test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-24">
      <description> Evaluation of a simple predicate, that uses the "!=" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works[1]//employee[empnum != "E1" and empnum != "E4"])</test>
      <result>
         <assert-xml><![CDATA[<employee name="Jane Doe 7" gender="female">
   <empnum>E2</empnum>
   <pnum>P1</pnum>
   <hours>40</hours>
  </employee><employee name="John Doe 8" gender="male">
   <empnum>E2</empnum>
   <pnum>P2</pnum>
   <hours>80</hours>
  </employee><employee name="Jane Doe 9" gender="female">
   <empnum>E3</empnum>
   <pnum>P2</pnum>
   <hours>20</hours>
  </employee><employee name="John Doe 10" gender="male">
   <empnum>E3</empnum>
   <pnum>P2</pnum>
   <hours>20</hours>
  </employee>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-25">
      <description> Evaluation of a simple predicate, that uses the "&lt;" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[(/works//hours[xs:integer(.) < 13])]]></test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-26">
      <description> Evaluation of a simple predicate, that uses the "&lt;=" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[(/works//hours[xs:integer(.) <= 12])]]></test>
      <result>
         <assert-xml><![CDATA[<hours>12</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-27">
      <description> Evaluation of a simple predicate, that uses the "&gt;" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works//hours[xs:integer(.) &gt; 79])</test>
      <result>
         <assert-xml><![CDATA[<hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-28">
      <description> Evaluation of a simple predicate, that uses the "&gt;=" operator. </description>
      <created by="Carmelo Montanez" on="2005-09-01"/>
      <environment ref="works-mod"/>
      <test>(/works//hours[xs:integer(.) &gt;= 80])</test>
      <result>
         <assert-xml><![CDATA[<hours>80</hours><hours>80</hours><hours>80</hours>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicates-29">
      <description> A negative test for numeric range used as filter expression. </description>
      <created by="Carmelo Montanez" on="2006-03-17"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[let $foo := <element1><element2>some content</element2></element1> return $foo[(2 to 5)]]]></test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>

   <test-case name="predicates-30">
      <description> Evaluation of predicates reordering by an implementation </description>
      <created by="Carmelo Montanez" on="2006-03-21"/>
      <environment ref="works-mod"/>
      <test>for $x in /works/employee[fn:position() lt 5][fn:position() mod 2 eq 1] return (fn:data($x/empnum), fn:data($x/pnum))</test>
      <result>
         <assert-string-value>E1 P1 E1 P3</assert-string-value>
      </result>
   </test-case>

   <test-case name="predicates-31">
      <description> Evaluation of predicates reordering by an implementation </description>
      <created by="Carmelo Montanez" on="2006-03-21"/>
      <environment ref="works-mod"/>
      <test>for $x in /works/employee[fn:position() mod 2 eq 1][fn:position() lt 5] return (fn:data($x/empnum), fn:data($x/pnum))</test>
      <result>
         <assert-string-value>E1 P1 E1 P3 E1 P5 E2 P1</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="predicates-32">
      <description> Numeric predicate computed by subscripting </description>
      <created by="Michael Kay" on="2013-11-02"/>
      <dependency type="spec" value="XQ10+"/>
      <test>
        declare variable $i := ("x", 1);
        declare variable $j := $i[position() ne 1];
        $i[$j]      
      </test>
      <result>
         <assert-eq>"x"</assert-eq>
      </result>
   </test-case>

   <test-case name="predicatesns-1">
      <description> Evaluation of a simple predicate with a "true" value (uses "fn:true"). Use of fn:count to avoid empty file. Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>fn:count((//integer[fn:true()]))</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="predicatesns-2">
      <description> Evaluation of a simple predicate with a "false" value (uses "fn:false"). Use of fn:count to avoid empty file. Not Schema dependent. Use fn:count to avoid empty file. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>fn:count((//integer[fn:false()]))</test>
      <result>
         <any-of>
            <assert-eq>0</assert-eq>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="predicatesns-3">
      <description> Evaluation of a simple predicate with a "true" value (uses "fn:false" and fn:not()). Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(//integer[fn:not(fn:false())])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-4">
      <description> Evaluation of a simple predicate set to a boolean expression ("and" operator). Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(//integer[fn:true() and fn:true()])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-5">
      <description> Evaluation of a simple predicate set to a boolean expression ("or" operator). Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(//integer[fn:true() or fn:true()])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-6">
      <description> Evaluation of a simple predicate set to a boolean expression ("and" operator). Returns "false" Uses "fn:count" to avoid empty file. Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>fn:count((//integer[fn:false() and fn:false()]))</test>
      <result>
         <any-of>
            <assert-eq>0</assert-eq>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="predicatesns-7">
      <description> Evaluation of a simple predicate set to a boolean expression ("or" operator). Returns "false" Uses "fn:count" to avoid empty file. Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>fn:count((//integer[fn:false() or fn:false()]))</test>
      <result>
         <any-of>
            <assert-eq>0</assert-eq>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="predicatesns-8">
      <description> Evaluation of a simple predicate, that uses the "xs:string()" function. Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(/root/string[xs:string(.) = "A String Function"])</test>
      <result>
         <assert-xml><![CDATA[<string>A String Function</string>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-9">
      <description> Evaluation of a simple predicate, that uses the "xs:integer()" function. Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(/root/integer[xs:integer(.) = 12678967543233])</test>
      <result>
         <assert-xml><![CDATA[<integer>12678967543233</integer>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-10">
      <description> Evaluation of a simple predicate, that uses the "xs:decimal()" function. Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(/root/decimal[(xs:decimal(.) = 12678967.543233)])</test>
      <result>
         <assert-xml><![CDATA[<decimal attr="12678967.543233">12678967.543233</decimal>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-11">
      <description> Evaluation of a simple predicate, that uses the "xs:float()" function. Not Schema dependent . </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(/root/float[xs:float(.) = xs:float(1267.43233E12)])</test>
      <result>
         <assert-xml><![CDATA[<float>1267.43233E12</float>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-12">
      <description> Evaluation of a simple predicate, that uses the "xs:double()" function. Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(/root/double[xs:double(.) = 1267.43233E12])</test>
      <result>
         <assert-xml><![CDATA[<double>1267.43233E12</double>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-13">
      <description> Evaluation of a simple predicate, that uses the "xs:boolean" function. Not Schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(/root/boolean[xs:boolean(.) = fn:true()])</test>
      <result>
         <assert-xml><![CDATA[<boolean>true</boolean>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="predicatesns-14">
      <description> Evaluation of a simple predicate, that uses the "xs:date()" function. Not schema dependent. </description>
      <created by="Carmelo Montanez" on="2006-03-15"/>
      <environment ref="atomicns"/>
      <test>(/root/date[xs:date(.) = xs:date("2000-01-01+05:00")])</test>
      <result>
         <assert-xml><![CDATA[<date>2000-01-01+05:00</date>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-Predicates-1">
      <description> Predicate combined with 'treat as'. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>"c"[. treat as xs:string]</test>
      <result>
         <assert-string-value>c</assert-string-value>
      </result>
   </test-case>

   <test-case name="K2-Predicates-2">
      <description> Apply a predicate to directly constructed nodes. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[last()]]]></test>
      <result>
         <assert-xml><![CDATA[<c/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-Predicates-3">
      <description> Apply a predicate to directly constructed nodes. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[last() - 1]]]></test>
      <result>
         <assert-xml><![CDATA[<b/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-Predicates-4">
      <description> Apply a predicate to directly constructed nodes. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[1]]]></test>
      <result>
         <assert-xml><![CDATA[<a/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-Predicates-5">
      <description> Apply two identical numeric predicates after each other. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[(<a/>, <b/>, <c/>)[1][1]]]></test>
      <result>
         <assert-xml><![CDATA[<a/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-Predicates-6">
      <description> Apply a predicate to a node constructor. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[<b attr="f"/>[1]]]></test>
      <result>
         <assert-xml><![CDATA[<b attr="f"/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-Predicates-7">
      <description> Apply last() to ancestor-or-self within a predicate. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[<r>{<e xml:lang="ene"/>/(ancestor-or-self::*/@xml:lang)[last()]}</r>]]></test>
      <result>
         <assert-xml><![CDATA[<r xml:lang="ene"/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-Predicates-8">
      <description> Use an axis step on an expression which has static type item(), from within a predicate. </description>
      <created by="Frans Englich" on="2008-11-13"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[declare function local:foo($arg as item()) { $arg[@arg] }; local:foo(<e arg="">result</e>)]]></test>
      <result>
         <assert-xml><![CDATA[<e arg="">result</e>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-Predicates-9">
      <description> Use an axis step on an expression which has static type item(), from within a path. </description>
      <created by="Frans Englich" on="2008-11-13"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[declare function local:foo($arg as item()) { string($arg/@arg) }; local:foo(<e arg="result"/>)]]></test>
      <result>
         <assert-string-value>result</assert-string-value>
      </result>
   </test-case>
   
    <test-case name="cbcl-filterexpr-001">
      <description> Test that negated floating point comparisons against the position variable optimize correctly. </description>
      <created by="Oliver Hallam" on="2008-09-19"/>     
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
      	declare function local:nan() { xs:float("NaN") }; 
      	(1 to 10)[not(position() < xs:float("NaN"))]
      ]]></test>
      <result>
         <assert-string-value>1 2 3 4 5 6 7 8 9 10</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-001">
      <description> test fn:first-in-sequence on sub-expression where quant = 1 </description>
      <created by="Tim Mills" on="2008-04-15"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else () }; ( local:generate(0), 1, local:generate(0) )[1]</test>
      <result>
         <assert-string-value>1</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-002">
      <description> test fn:first-in-sequence on a for expression </description>
      <created by="Tim Mills" on="2008-04-15"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then (1, 2, 3) else $arg }; ( local:generate(()), for $x in local:generate(0) return $x + 2 )[1]</test>
      <result>
         <assert-string-value>3</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-003">
      <description> test fn:first-in-sequence on a for expression </description>
      <created by="Tim Mills" on="2008-04-15"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 0 else () }; ( local:generate(()), for $x in local:generate(0) return $x + 2 )[1]</test>
      <result>
         <assert-string-value>2</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-004">
      <description> test fn:first-in-sequence on a for-at expression </description>
      <created by="Tim Mills" on="2008-04-15"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1]</test>
      <result>
         <assert-string-value>2</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-005">
      <description> test fn:first-in-sequence on a for-at expression </description>
      <created by="Tim Mills" on="2008-04-15"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1]</test>
      <result>
         <assert-string-value>2</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-006">
      <description> test fn:first-in-sequence on a map expression </description>
      <created by="Tim Mills" on="2008-04-15"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else ('d' ) }; ( if (local:generate(1) = 'd') then () else 1, for $x in local:generate(0) return fn:lower-case($x))[1]</test>
      <result>
         <assert-string-value>a</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-007">
      <description> test fn:first-in-sequence on a map expression </description>
      <created by="Tim Mills" on="2008-04-15"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:integer? { $arg }; ( if (local:generate(0) = 0) then () else 1, for $x in local:generate(0) return -$x)[1]</test>
      <result>
         <assert-string-value>0</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-008">
      <description> test fn:first-in-sequence on a distinct-doc-order </description>
      <created by="Tim Mills" on="2008-04-15"/>      
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[( (<a><b>cheese</b></a>)/b )[1]]]></test>
      <result>
         <assert-xml>&lt;b&gt;cheese&lt;/b&gt;</assert-xml>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-009">
      <description> test fn:first-in-sequence on a for-each expression Author: Tim Mills </description>
      <created by="Oliver Hallam" on="2008-04-15"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; ( local:generate(()), for $x in local:generate(0) return 3)[1]</test>
      <result>
         <assert-string-value>3</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-010">
      <description> test fn:boolean on fn:first-in-sequence </description>
      <created by="Oliver Hallam" on="2008-04-22"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(0)[1])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-011">
      <description> test fn:boolean on fn:first-in-sequence </description>
      <created by="Oliver Hallam" on="2008-04-22"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(1)[1])</test>
      <result>
         <assert-false/>
      </result>
   </test-case>
   

   <test-case name="cbcl-first-in-sequence-012">
      <description> test fn:first-in-sequence on a for-each expression </description>
      <created by="Oliver Hallam" on="2008-04-22"/>
      <dependency type="spec" value="XQ10+"/>     
      <test>declare function local:generate($arg as xs:boolean) as xs:string+ { if ($arg) then ('a', 'b', 'c') else ('A', 'B', 'C') }; ( for $x in local:generate(true()) return 3)[1]</test>
      <result>
         <assert-string-value>3</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="cbcl-filter-001">
      <description> Tests various filter optimizations </description>
      <created by="Nick Jones" on="2008-06-27"/>
      <dependency type="spec" value="XQ10+ XP30+"/>     
      <test>let $x := exists((1 to 10)[. mod 2 = 0]) return (1 to 100)[position() mod 2 = 0 and position() mod 3 = 0 and $x]</test>
      <result>
         <assert-string-value>6 12 18 24 30 36 42 48 54 60 66 72 78 84 90 96</assert-string-value>
      </result>
   </test-case>

   <test-case name="filter-limits-001">
      <description>Test numeric predicates at integer limits</description>
      <created by="Christian Gruen" on="2016-02-04"/>
      <dependency type="spec" value="XQ10+"/>     
      <test>'a'[2147483649]</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="filter-limits-002">
      <description>Test numeric predicates at integer limits</description>
      <created by="Christian Gruen" on="2016-02-04"/>
      <dependency type="spec" value="XQ10+"/>     
      <test>'a'[4294967296]</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="filter-limits-003">
      <description>Test numeric predicates at integer limits</description>
      <created by="Christian Gruen" on="2016-02-04"/>
      <dependency type="spec" value="XQ10+"/>     
      <test>'a'[4294967297]</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
      
</test-set>
