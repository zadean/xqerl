<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="prod-TypeswitchExpr">
   <description>Tests for the TypeswitchExpr production</description>
   <link type="spec" document="http://www.w3.org/TR/xquery-30/"
         idref="doc-xquery30-TypeswitchExpr"/>
   <link type="spec" document="XQuery" section-number="3.12.2" idref="id-typeswitch"/>
   
   <dependency type="spec" value="XQ10+"/>
   
   <environment name="ListUnionTypes">
      <schema uri="http://www.w3.org/XQueryTest/ListUnionTypes" file="ValidateExpr/listunion.xsd">
         <description>A schema defining a list of unions.</description>
         <created by="Anonymous" on="2006-06-07"/>
      </schema>
   </environment> 

   <test-case name="typeswitchhc1">
      <description> Simple test for evaluation of atomic value (integer) and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (5) 
        case $i as xs:integer return <wrap>test passed - integer data type</wrap> 
        case $i as xs:date return <wrap>test failed</wrap> 
        case $i as xs:time return <wrap>test failed</wrap> 
        case $i as xs:string return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - integer data type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc2">
      <description> Simple test for evaluation of atomic value (decimal) and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (5.1) 
        case $i as xs:decimal return <wrap>test passed - 5.1 is a decimal type</wrap> 
        case $i as xs:float return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - 5.1 is a decimal type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc3">
      <description> Simple test for evaluation of atomic value (double) and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (5.1E2) 
        case $i as xs:integer return <wrap>test failed2</wrap> 
        case $i as xs:double return <wrap>test passed - 5.1E2 is a double type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - 5.1E2 is a double type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc4">
      <description> Simple test for evaluation of atomic value (string) and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch ("A String") 
        case $i as xs:decimal return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:string return <wrap>test passed - "A String" is a string type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - "A String" is a string type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc5">
      <description> Simple test for evaluation of atomic value (float) and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (1267.43233E12) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test passed - 1267.43233E12 is a double type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - 1267.43233E12 is a double type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc6">
      <description> Simple test for evaluation of simple boolean expression and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(1 > 2) case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:boolean return <wrap>test passed - 1 > 2 is a boolean type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - 1 &gt; 2 is a boolean type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc7">
      <description> Simple test for evaluation of simple date expression and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(xs:date("1999-05-31")) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:date return <wrap>test passed - xs:date("1999-05-31")is of date type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - xs:date("1999-05-31")is of date type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc8">
      <description> Simple test for evaluation of simple time expression and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(xs:time("12:00:00")) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:time return <wrap>test passed - xs:time("12:00:00")is of time type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - xs:time("12:00:00")is of time type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc9">
      <description> Simple test for evaluation of simple dateTime expression and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(xs:dateTime("1999-12-31T19:20:00")) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:dateTime return <wrap>test passed - xs:dateTime("1999-12-31T19:20:00")is of dateTime type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - xs:dateTime("1999-12-31T19:20:00")is of dateTime type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc10">
      <description> Simple test for evaluation of simple anyURI expression and various data types for case evaluation </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(xs:anyURI("http://example.com")) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:anyURI return <wrap>test passed - xs:anyURI("http://www.example.com")is of anyURI type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - xs:anyURI("http://www.example.com")is of anyURI type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc11">
      <description> Simple test for evaluation of various expressions and should mathc the deafult value </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(123) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:anyURI return <wrap>test failed</wrap> 
        default return <wrap>test passed - 123 is an integer (not an option on any cases)</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - 123 is an integer (not an option on any cases)</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc12">
      <description> Simple test for evaluating dynamic error raised by default clause (no error raised) </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(123) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test passed - If a dynamic error is generated, then test failed.</wrap> 
        default return 12 div 0]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - If a dynamic error is generated, then test failed.</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc13">
      <description> Simple test for typeswitch with operand expression (if Expression) evaluating to an integer. </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(if (1 lt 2) then 3 else 4.5E4) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test passed - "(1 lt 2) then 3 else 4.5E4" should evaluate to an integer</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - "(1 lt 2) then 3 else 4.5E4" should evaluate to an integer</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc14">
      <description> Simple test for typeswitch with operand expression (boolean) evaluating to boolean type </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(fn:true() and fn:true()) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:boolean return <wrap>test passed - "fn:true() and fn:true()" should evaluate to boolean type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - "fn:true() and fn:true()" should evaluate to boolean type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc15">
      <description> Simple test for typeswitch with operand expression (boolean or boolean) evaluating to boolean type </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(fn:true() or fn:false()) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:boolean return <wrap>test passed - "fn:true() or fn:false()" should evaluate to boolean type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - "fn:true() or fn:false()" should evaluate to boolean type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc16">
      <description> Simple test for typeswitch with operand expression, that is itself a typeswitch expression evaluating to integer type </description>
      <created by="Carmelo Montanez" on="2005-02-14"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch(typeswitch (1) 
        case $i as xs:integer return $i default return <a>fn:false</a> ) 
        case $i as xs:string return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test passed - the operand expression should evaluate to an integer type</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-xml><![CDATA[<wrap>test passed - the operand expression should evaluate to an integer type</wrap>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="typeswitchhc17">
      <description> Simple test for evaluation of atomic value (integer) and return contains integer expression </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (5) 
        case $i as xs:integer return xs:integer(1 + 1) 
        case $i as xs:date return <wrap>test failed</wrap> 
        case $i as xs:time return <wrap>test failed</wrap> 
        case $i as xs:string return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-eq>2</assert-eq>
      </result>
   </test-case>

   <test-case name="typeswitchhc18">
      <description> Simple test for evaluation of atomic value (decimal) and return clause conatining an arithmetic expression with decimals </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (5.1) 
        case $i as xs:decimal return xs:decimal(1.1 + 3.1) 
        case $i as xs:float return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:double return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-string-value>4.2</assert-string-value>
      </result>
   </test-case>

   <test-case name="typeswitchhc19">
      <description> Simple test for evaluation of atomic value (double) and return clause containing a double addition operation. </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (5.1E2) 
        case $i as xs:integer return <wrap>test failed2</wrap> 
        case $i as xs:double return xs:double(5.1E2 + 1.1E2) 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-eq>620</assert-eq>
      </result>
   </test-case>

   <test-case name="typeswitchhc20">
      <description> Simple test for evaluation of atomic value (string) and return clause containing a string operation </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch ("A String") 
        case $i as xs:decimal return <wrap>test failed</wrap> 
        case $i as xs:integer return <wrap>test failed</wrap> 
        case $i as xs:string return fn:string-length($i) 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-eq>8</assert-eq>
      </result>
   </test-case>

   <test-case name="typeswitchhc21">
      <description> Simple test for evaluation of atomic value ("1") and return clause containing an fn:count() </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (1) 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:integer return fn:count((1, 2, 3)) 
        case $i as xs:string return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-eq>3</assert-eq>
      </result>
   </test-case>

   <test-case name="typeswitchhc22">
      <description> Simple test for evaluation of atomic value ("1") and return clause containing a subtraction operation </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (1) 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:integer return 5 - 3 
        case $i as xs:string return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-eq>2</assert-eq>
      </result>
   </test-case>

   <test-case name="typeswitchhc23">
      <description> Simple test for evaluation of atomic value ("1") and return clause containing a multiplication operation </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (1) 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:integer return 5 * 2 
        case $i as xs:string return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-eq>10</assert-eq>
      </result>
   </test-case>

   <test-case name="typeswitchhc24">
      <description> Simple test for evaluation of atomic value ("1") and return clause containing a division (div) operation </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (1) 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:integer return 10 div 2 
        case $i as xs:string return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-eq>5</assert-eq>
      </result>
   </test-case>

   <test-case name="typeswitchhc25">
      <description> Simple test for evaluation of atomic value ("1") and return clause containing a division (idiv) operation </description>
      <created by="Carmelo Montanez" on="2005-08-25"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        typeswitch (1) 
        case $i as xs:double return <wrap>test failed</wrap> 
        case $i as xs:integer return 10 idiv 2 
        case $i as xs:string return <wrap>test failed</wrap> 
        default return <wrap>test failed</wrap>]]></test>
      <result>
         <assert-eq>5</assert-eq>
      </result>
   </test-case>

   <test-case name="K-sequenceExprTypeswitch-1">
      <description> typeswitch test where the sequence types only differs in cardinality. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(typeswitch((1, 2)) case xs:integer return -1 case xs:integer+ return 1 default return -2) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-sequenceExprTypeswitch-2">
      <description> A string literal is of type xs:string, even though it can be promoted to xs:anyURI. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(typeswitch("a string") case xs:anyURI return -1 case xs:string return 1 default return -2) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-sequenceExprTypeswitch-3">
      <description> typeswitch test: A string literal is of type xs:string, even though it can be promoted to xs:untypedAtomic. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(typeswitch("a string") case xs:untypedAtomic return -1 case xs:string return 1 default return -2) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-sequenceExprTypeswitch-4">
      <description> A sequence of atomic items are not treated individually, but as a whole. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(typeswitch((1, "a string")) case xs:integer return -1 case xs:string return -2 case xs:anyAtomicType+ return 1 default return -3) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-sequenceExprTypeswitch-5">
      <description> A typeswitch scenario which in some implementations trigger certain optimization code paths. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(typeswitch(((1, current-time())[1])) case element() return -1 case xs:integer return 1 default return -2) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-sequenceExprTypeswitch-6">
      <description> A typeswitch scenario involving empty-sequence(). Both the 'xs:integer*' branch and the 'empty-sequnec()' branch are valid. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(typeswitch(()) case xs:integer* return 1 case empty-sequence() return 1 default return -2) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-sequenceExprTypeswitch-7">
      <description> A typeswitch with an operand expression being the comma operator using no paranteses. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(typeswitch(1, 2, 3) case xs:string+ return -1 case xs:integer+ return 1 default return -2) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-sequenceExprTypeswitch-8">
      <description> A typeswitch where the case clauses will never be evaluated. In some implementations this trigger optimization code paths. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>(typeswitch(1, 2, current-time()) case element() return -1 case document-node() return -2 default return 1) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-1">
      <description> Extract the EBV from the result of a typeswitch. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>boolean(typeswitch (current-time(), 1, 3e3, "foo") case node() return 0 case xs:integer return 3 case xs:anyAtomicType return true() default return -1)</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-2">
      <description> A default clause must be specified. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>typeswitch(current-time()) case node() return 0 case xs:integer return 3 case xs:anyAtomicType return true()</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-3">
      <description> Parenteses must be specified for the expression that's switched. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>typeswitch 1 case node() return 0 case xs:integer return 3 default return true()</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-4">
      <description> A variable is only in scope for the case branch it is declared for. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[typeswitch (1, 2, 3) case $i as node() return <e/> case xs:integer* return $i default return true()]]></test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-5">
      <description> A variable is only in scope for the case branch it is declared for(#2). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>typeswitch (1, 2, 3) case node() return $i case $i as xs:integer return 1 default return true()</test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-6">
      <description> A variable is only in scope for the case branch it is declared for(#3). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[typeswitch (1, 2, 3) case node() return <e/> case $i as xs:integer return 1 default return $i]]></test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-7">
      <description> A variable is only in scope for the case branch it is declared for(#3). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[typeswitch (1, 2, 3) case node() return <e/> case xs:integer* return $i default $i return 1]]></test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-8">
      <description> A type declaration is not allowed in the default branch. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[typeswitch (1, 2, 3) case node() return <e/> case xs:integer return 3 default $i as item() return 1]]></test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-9">
      <description> Typeswitch variables are not in scope outside the typeswitch expression. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[typeswitch (1, 2, 3) case node() return <e/> case xs:integer return 3 default $i return 1, $i]]></test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-10">
      <description> Typeswitch variables are not in scope outside the typeswitch expression. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[typeswitch (1, 2, 3) case node() return <e/> case $i as xs:integer return 3 default return 1, $i]]></test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-11">
      <description> A variable declared in the default branch doesn't carry over to a subsequent typeswitch. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[typeswitch (1, 2, 3) case node() return <e/> default $i return 1 , typeswitch (1, 2, 3) case xs:integer* return $i default return 1]]></test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-12">
      <description> Two nested typeswitches. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
         declare variable $i := (attribute name {"content"}, <a attr="content"/>, <e/>, 1, "str", <!-- a comment -->); 
         <d> { 
            typeswitch(
               typeswitch($i) 
                  case $b as element(e) return concat("Found an element by name ", $b) 
                  case $b as element() return comment{concat("Found: ", $b)} 
                  case $c as attribute(doesntMatch) return $c/.. 
                  default $def return $def) 
               case $str as xs:string return "A string" 
               case $attr as attribute() return string($attr) 
               default $def return $def 
          } </d>]]>
      </test>
      <result>
         <assert-xml><![CDATA[<d name="content"><a attr="content"/><e/>1 str<!-- a comment --></d>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-13">
      <description> A complex query that constructs nodes in the wrong order. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[declare variable $i := (<e/>, attribute name {"content"}, <a attr="content"/>, <e/>, 1, "str", <!-- a comment -->); <d> { typeswitch(typeswitch($i) case $b as element(e) return concat("Found an element by name ", $b) case $b as element() return comment{concat("Found: ", $b)} case $c as attribute(doesntMatch) return $c/.. default $def return $def) case $str as xs:string return "A string" case $attr as attribute() return string($attr) default $def return $def } </d>]]></test>
      <result>
         <error code="XQTY0024"/>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-14">
      <description> Use the focus from within a typeswitch's case-branch. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[<e/>/(typeswitch (self::node()) case $i as node() return . default return 1)]]></test>
      <result>
         <assert-xml><![CDATA[<e/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-15">
      <description> Use the focus from within a typeswitch's case-branch. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[<e/>/(typeswitch (self::node()) case $i as xs:integer return $i default $v return $v)]]></test>
      <result>
         <assert-xml><![CDATA[<e/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="K2-sequenceExprTypeswitch-16">
      <description> Use variables with type declarations. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[typeswitch(<e/>, <e/>) case $b as element() return concat("", $b treat as element()) default return 1]]></test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="typeswitch-union-nomatch" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with union, no match</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 typeswitch (<e/>) 
	 case $i as xs:integer | xs:string return $i
	 default $v return 0
	 ]]></test>
	 <result>
	   <assert-eq>0</assert-eq>
	 </result>
   </test-case>

   <test-case name="typeswitch-union-nomatch-2" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with union, no match</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 typeswitch (<e/>) 
	 case xs:integer | xs:string return 1
	 default $v return 0
	 ]]></test>
	 <result>
	   <assert-eq>0</assert-eq>
	 </result>
   </test-case>

   <test-case name="typeswitch-union-branch-1" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with union, a match first branch only; check type of bound variable</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 typeswitch (47) 
	 case $i as xs:integer | xs:string return $i
	 default $v return 0
	 ]]></test>
	 <result>
	   <all-of>
		 <assert-eq>47</assert-eq>
		 <assert-type>xs:integer</assert-type>
	   </all-of>
	 </result>
   </test-case>

   <test-case name="typeswitch-union-branch-1-dup" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with union, a match first branch only; check type of bound variable</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 typeswitch (47) 
	 case $i as xs:integer | xs:string return $i
	 case $i as xs:integer return $i
	 default $v return 0
	 ]]></test>
	 <result>
	   <all-of>
		 <assert-eq>47</assert-eq>
		 <assert-type>xs:integer</assert-type>
	   </all-of>
	 </result>
   </test-case>

   <test-case name="typeswitch-union-branch-2" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with union, a match second branch only; check type of bound variable</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 typeswitch (47) 
	 case $i as xs:string | xs:integer return $i
	 default $v return 0
	 ]]></test>
	 <result>
	   <all-of>
		 <assert-eq>47</assert-eq>
		 <assert-type>xs:integer</assert-type>
	   </all-of>
	 </result>
   </test-case>

   <test-case name="typeswitch-union-branch-2-dup" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with union, a match second branch only; check type of bound variable</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 typeswitch (47) 
	 case $i as xs:string | xs:integer return $i
	 case $i as xs:integer return $i
	 default $v return 0
	 ]]></test>
	 <result>
	   <all-of>
		 <assert-eq>47</assert-eq>
		 <assert-type>xs:integer</assert-type>
	   </all-of>
	 </result>
   </test-case>

   <test-case name="typeswitch-union-branch-both" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with union, a match second branch only; check type of bound variable</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 typeswitch (xs:integer(47)) 
	 case $i as xs:decimal | xs:integer return $i
	 default $v return 0
	 ]]></test>
	 <result>
	   <all-of>
		 <assert-eq>47</assert-eq>
		 <assert-type>xs:decimal</assert-type>
	   </all-of>
	 </result>
   </test-case>

   <test-case name="typeswitch-union-branch-both-dup" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with union, a match second branch only; check type of bound variable</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 typeswitch (xs:integer(47)) 
	 case $i as xs:decimal | xs:integer return $i
	 case $i as xs:decimal return $i
	 default $v return 0
	 ]]></test>
	 <result>
	   <all-of>
		 <assert-eq>47</assert-eq>
		 <assert-type>xs:decimal</assert-type>
	   </all-of>
	 </result>
   </test-case>

   <test-case name="typeswitch-union-multi" covers-30="typeswitch-union-cases">
	 <description>Typeswitch with N-way union</description>
	 <created by="Mary Holstege" on="2011-07-28"/>
	 <dependency type="spec" value="XQ30+"/>
	 <test><![CDATA[
	 for $x in (<e/>, 1, "x") return
	 typeswitch ($x) 
	 case $i as xs:integer | xs:boolean | element() return 1
	 default $v return 0
	 ]]></test>
	 <result>
	   <assert-deep-eq>1, 1, 0</assert-deep-eq>
	 </result>
   </test-case>
   
   <test-case name="typeswitch-union-in-xquery-10">
	 <description>Typeswitch with union of types disallowed in XQuery 1.0</description>
	 <created by="Michael Kay" on="2011-07-28"/>
	 <dependency type="spec" value="XQ10"/>
	 <test><![CDATA[
	 for $x in (<e/>, 1, "x") return
	 typeswitch ($x) 
	 case $i as xs:integer | xs:boolean | element() return 1
	 default $v return 0
	 ]]></test>
	 <result>
	   <error code="XPST0003"/>
	 </result>
   </test-case>
   
   <test-case name="typeswitch-112" covers-30="union-as-sequence-type">
      <description>purpose: Test that a value is an instance of a simple union type. </description>
      <created by="Michael Kay" on="2012-10-02"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
      	declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
        typeswitch (23)
        case $i as lu:unionType return true()
        default $v return false()
      </test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   
   <test-case name="typeswitch-113" covers-30="union-as-sequence-type">
      <description>purpose: Test that a value cannot be tested to be an instance of a union type derived by restriction. </description>
      <created by="Michael Kay" on="2012-10-02"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
      	declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
        typeswitch (-23)
        case $i as lu:restrictedUnionType return true()
        default $v return false()
      </test>
      <result>
         <error code="XPST0051"/>
      </result>
   </test-case>
   
   <test-case name="typeswitch-114" covers-30="union-as-sequence-type">
      <description>purpose: Test that a value cannot be tested to be an instance of a list whose item type is a union. </description>
      <created by="Michael Kay" on="2012-10-02"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
      	declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
        typeswitch (-23)
        case $i as lu:listType return true()
        default $v return false()
      </test>
      <result>
         <error code="XPST0051"/>
      </result>
   </test-case>
   
   <test-case name="typeswitch-115" covers-30="union-as-sequence-type">
      <description>purpose: Test that a value cannot be tested to be an instance of a union type with a list in its membership. </description>
      <created by="Michael Kay" on="2012-10-02"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
      	declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
        typeswitch (-23)
        case $i as lu:unionOfListType return true()
        default $v return false()
      </test>
      <result>
         <error code="XPST0051"/>
      </result>
   </test-case>
   
   <test-case name="typeswitch-116" covers-30="union-as-sequence-type">
      <description>purpose: Test that a value can be tested to be an instance of a union type with a union in its membership. </description>
      <created by="Michael Kay" on="2012-10-02"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
      	declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
        
        (typeswitch (current-date())
        case $i as lu:unionOfUnionType return true()
        default $v return false())
          and
        (typeswitch (23)
        case $i as lu:unionOfUnionType return true()
        default $v return false())  
      </test>
      <result>
         <assert-true/>
      </result>
   </test-case>  
   
   <test-case name="typeswitch-117" covers="array-general map-general">
      <description>purpose: Test typeswitch with maps and arrays. </description>
      <created by="Michael Kay" on="2015-04-16"/>
      <environment ref="array-and-map"/>
      <dependency type="spec" value="XQ31+"/>
      <test>
      	let $x := [map{'x':1, 'y':2}, 'x']
      	let $y := [array{1, 2, 3}, 1]
      	let $z := ($x, $y)
      	for $e in $z return
      	  typeswitch($e?1)
      	  case $A as array(*) return array:get($A, $e?2)
      	  case $M as map(*) return map:get($M, $e?2)
      	  default return error()
      </test>
      <result>
         <assert-deep-eq>1,1</assert-deep-eq>
      </result>
   </test-case>   
   
   <test-case name="typeswitch-118" covers="array-general map-general">
      <description>
        Purpose: Test typeswitch where a branch does not get executed. 
        Detecting a type error here is permitted but not required.
      </description>
      <created by="Michael Kay" on="2015-04-16"/>
      <modified by="Michael Kay" on="2018-05-10" change="The test as written was failing XPTY0004 for the wrong reasons"/>
      <environment ref="array-and-map"/>
      <dependency type="spec" value="XQ31+"/>
      <test>
      	let $x := map{'x':1, 'y':2}
      	let $y := map{'A':1, 'B':2}
      	let $z := ($x, $y, [])
      	for $e in $z[position() lt 3] return
      	  typeswitch($e)
      	  case $A as array(*) return array:get($A, 'A') (: deliberate: array:get requires an integer :)
      	  case $M as map(*) return map:get($M, 'A')
      	  default return error()
      </test>
      <result>
         <any-of>
           <error code="XPTY0004"/>
           <assert-eq>1</assert-eq>
         </any-of>
      </result>
   </test-case>   
   
   <test-case name="typeswitch-119" covers="array-general map-general">
      <description>
         Purpose: Test typeswitch with an impossible branch. This is not an error.
      </description>
      <created by="Michael Kay" on="2018-05-10"/>
      <environment ref="array-and-map"/>
      <dependency type="spec" value="XQ31+"/>
      <test>
         let $x := map{'x':1, 'y':2}
         let $y := map{'A':1, 'B':2}
         let $z := ($x, $y, [])
         for $e as map(*) in $z[position() lt 3] return
         typeswitch($e)
         case $A as array(*) return array:get($A, 1)
         case $M as map(*) return map:get($M, 'A')
         default return error()
      </test>
      <result>
          <assert-eq>1</assert-eq>
      </result>
   </test-case>   
   
   <test-case name="cbcl-typeswitch-001">
      <description> Tests evaluateoptionalitem </description>
      <created by="Nick Jones" on="2008-06-26"/>
      <test>
        upper-case(typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return "int" default return "false")
      </test>
      <result>
         <assert-string-value>INT</assert-string-value>
      </result>
   </test-case>

   <test-case name="cbcl-typeswitch-002">
      <description> Tests evaluateOptionalItem with default clause </description>
      <created by="Nick Jones" on="2008-06-26"/>
      <test>
        upper-case(typeswitch ((1 to 10)[. div 2 = 0]) case xs:integer+ return "int" default return "false")
      </test>
      <result>
         <assert-string-value>FALSE</assert-string-value>
      </result>
   </test-case>

   <test-case name="cbcl-typeswitch-003">
      <description> Tests typeswitch clause which always returns the same value </description>
      <created by="Nick Jones" on="2008-06-26"/>
      <test>
        typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return true() default return true()
      </test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="cbcl-typeswitch-004">
      <description> Tests optimization of typeswitch clause to "instance of" </description>
      <created by="Nick Jones" on="2008-06-26"/>
      <test>
        typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return false() default return true()
      </test>
      <result>
         <assert-false/>
      </result>
   </test-case>

   <test-case name="cbcl-typeswitch-005">
      <description> Tests which calls Evaluate method </description>
      <created by="Nick Jones" on="2008-06-26"/>
      <test>
        subsequence((1 to 10)[. mod 2 = 0] instance of xs:integer+,1)
      </test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="cbcl-typeswitch-006">
      <description> Test which calls EvaluateToOptionalItem method </description>
      <created by="Nick Jones" on="2008-06-26"/>
      <test>xs:string((1 to 10)[. mod 2 = 0] instance of xs:integer+)</test>
      <result>
         <assert-string-value>true</assert-string-value>
      </result>
   </test-case>
   

</test-set>
