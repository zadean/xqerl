<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="app-Demos">
   <description>Some XQuery demonstration programs from CBCL and elsewhere</description>


   <test-case name="sudoku">
      <description> A sudoku solver </description>
      <created by="Nick Jones" on="2008-10-30"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        declare namespace fn = "sudoku";
        declare variable $board as xs:integer+ := 
        	( 1,0,0, 3,0,0, 6,0,0, 0,2,0, 5,0,0, 0,0,4, 0,0,9, 0,0,0, 
        	5,2,0, 0,0,0, 9,6,3, 0,0,0, 7,1,6, 0,0,0, 0,0,0, 0,0,0, 
        	0,8,0, 0,4,0, 9,0,0, 0,0,5, 3,0,7, 8,0,0, 4,0,6, 0,0,0, 
        	3,5,0, 0,0,0, 0,0,1);
        declare variable $rowStarts as xs:integer+ := (1, 10, 19, 28, 37, 46, 55, 64,73);
        declare variable $groups as xs:integer+ := 
        	( 1,1,1, 2,2,2, 3,3,3, 1,1,1, 2,2,2, 3,3,3, 1,1,1, 2,2,2, 3,3,3, 4,4,4, 
        	5,5,5, 6,6,6, 4,4,4, 5,5,5, 6,6,6, 4,4,4, 5,5,5, 6,6,6, 7,7,7, 8,8,8, 
        	9,9,9, 7,7,7, 8,8,8, 9,9,9, 7,7,7, 8,8,8, 9,9,9 );
        declare function fn:getRow ($board as xs:integer+, $index as xs:integer) as xs:integer+ { 
        	let $rowStart := floor(($index - 1) div 9) * 9 
        	return one-or-more($board[position() > $rowStart and position() <= $rowStart + 9]) 
        };
        declare function fn:getCol ($board as xs:integer+, $index as xs:integer) as xs:integer+ { 
        	let $gap := ($index - 1) mod 9, 
        	    $colIndexes := for $x in $rowStarts 
        	    		       return $x + $gap 
        	return one-or-more($board[position() = $colIndexes]) 
        };
        declare function fn:getGroup ($board as xs:integer+, $index as xs:integer) as xs:integer+ { 
        	let $group := $groups[$index] 
        	return one-or-more($board[for $x in position() return $groups[$x]= $group]) 
        };
        declare function fn:getAllowedValues ($board as xs:integer+, $index as xs:integer) as xs:integer* { 
        	let $existingValues := (fn:getRow($board, $index), fn:getCol($board, $index), fn:getGroup($board, $index)) 
        	return for $x in (1 to 9) return if (not($x = $existingValues)) then $x else () 
        };
        declare function fn:tryValues($board as xs:integer+, $emptyCells as xs:integer+, $possibleValues as xs:integer+) as xs:integer* { 
        	let $index as xs:integer := $emptyCells[1], 
        	    $newBoard as xs:integer+ := ($board[position() <$index], $possibleValues[1], $board[position() > $index]), 
        	    $result as xs:integer* := fn:populateValues($newBoard, $emptyCells[position() != 1]) 
        	return if (empty($result)) then if (count($possibleValues) > 1) then fn:tryValues($board, $emptyCells, one-or-more($possibleValues[position() != 1])) else () else $result 
        };
        declare function fn:populateValues($board as xs:integer+, $emptyCells as xs:integer*) as xs:integer*{ 
        	if (not(empty($emptyCells))) 
        	then let $index as xs:integer := exactly-one($emptyCells[1]), 
        			 $possibleValues as xs:integer* := distinct-values(fn:getAllowedValues($board, $index)) 
        		 return if (count($possibleValues) > 1) 
        		        then fn:tryValues($board, one-or-more($emptyCells), one-or-more($possibleValues)) 
        		        else if (count($possibleValues) = 1) 
        		        then let $newBoard as xs:integer+ :=($board[position() < $index], 
        		                   exactly-one($possibleValues[1]), $board[position() > $index]) 
        		             return fn:populateValues($newBoard, $emptyCells[position() != 1]) 
        		        else () 
        	else $board 
        };
        declare function fn:solveSudoku ($startBoard as xs:integer+) as xs:integer+{ 
        	let $emptyCells as xs:integer* :=
        			for $x in (1 to 81) 
        			return if ($startBoard[$x] = 0) then $x else (), 
        		$endBoard as xs:integer* :=fn:populateValues($startBoard,$emptyCells) 
        	return if (empty($endBoard)) then $startBoard else one-or-more($endBoard)
        };
        declare function fn:drawResult ($board as xs:integer+) as element(){ 
        	<html><head><title>Sudoku - XSLT</title><style>table {{ border-collapse: collapse; border: 1px solid black; }} td {{ padding: 10px; }} .norm {{ border-left: 1px solid #CCC; border-top: 1px solid #CCC; }} .csep {{ border-left: 1px solid black; }} .rsep {{ border-top: 1px solid black; }}</style></head><body>{fn:drawBoard($board)}</body></html> };
        declare function fn:drawBoard ($board as xs:integer+) as element(){ 
        	<table>{for $i in 1 to 9 return 
        		<tr>{for $j at $p in 1 to 9 
        			  let $pos := (($i - 1) * 9) + $j 
        			  return <td class="{if ($p mod 3 = 1) then 'csep' else ('norm')} {if ($i mod 3 = 1) then 'rsep' else ('norm')}"> {$board[$pos]}</td> 
        			  }</tr> }</table> 
        };
        fn:drawResult(fn:solveSudoku($board))
      ]]></test>
      <result>
         <assert-xml file="Demos/sudoku-result.xml"/>
      </result>
   </test-case>

   <test-case name="currencysvg">
      <description>Draw an SVG of currency exchange data.</description>
      <created by="Nick Jones" on="2008-10-30"/>
      <modified by="Michael Kay" on="2013-01-03" change="remove dependency on decimal precision (bug 20556)"/>
      <environment>
         <source role="." file="Demos/GBPNoon.xml">
            <description></description>
            <created by="Nick Jones" on="2008-10-30"/>
         </source>
      </environment> 
      <dependency type="spec" value="XQ10+"/>
      <test file="Demos/currencysvg.xq"/>
      <result>
         <assert-xml file="Demos/currencysvg-result.xml"/>
      </result>   
   </test-case>

   <test-case name="itunes">
      <description>
      	Bind the prefix 'svg' to the SVG namespace 
        Import a schema for the iTunes Music Library 
        Validate the iTunes Music Library against the schema 
        Get a list of all tracks with release dates 
        Distinct artists First/last dates Graph size 
        Calculates the position on the timeline of the track 
        Looks up a key returning a string element 
        Looks up a track returning the release date 
        Marks the years on the timeline </description>
      <created by="Nick Jones" on="2008-10-30"/>
      <modified by="Michael Kay" on="2013-01-03" change="remove dependency on decimal precision (bug 20556)"/>
      <environment>
         <source role="." file="Demos/iTunesMusicLibrary.xml" validation="strict">
            <description></description>
            <created by="Nick Jones" on="2008-10-30"/>
         </source>
         <schema uri="" file="Demos/iTunes.xsd">
         	<description>A Schema for iTunesMusicLibrary.xml</description>
         	<created by="Nick Jones" on="2008-10-30"/>
      	</schema>
      </environment> 
      <dependency type="spec" value="XQ10+"/>
      <dependency type="feature" value="schemaImport"/>
      <test file="Demos/iTunes3.xq"/>
      <result>
         <assert-xml file="Demos/iTunes3-result.xml"/>
      </result>
   </test-case>

   <test-case name="raytracer">
      <description>Magic number identifying the file as a "plain" ppm file width and height Maximum color value : Now the pixel data. We take each pixel in the image, and recenter it, so that the : y co-ordinate ($y-recentered) ranges from -0.5 at the bottom of the image, to 0.5 : at the top of the image. : : The aspect ratio is used to "stretch" the range of x-coordinate values to stop the : image from being skewed. plot-pixel returns us the rgb values of the color of this pixel. We convert these to an integer value in the range [0, 255], and output them. </description>
      <created by="Nick Jones" on="2008-10-30"/>
      <environment>
         <source role="." file="Demos/scene.xml">
            <description></description>
            <created by="Nick Jones" on="2008-10-30"/>
         </source>
      </environment>
      <module uri="http://www.xqsharp.com/raytracer" file="Demos/raytracer.xq"/>
      <module uri="http://www.xqsharp.com/raytracer/scene" file="Demos/scene.xq"/>
      <module uri="http://www.xqsharp.com/raytracer/vector" file="Demos/vector.xq"/>
      <module uri="http://www.xqsharp.com/raytracer/shapes" file="Demos/shapes.xq"/>
      <module uri="http://www.xqsharp.com/raytracer/materials" file="Demos/materials.xq"/>
      <module uri="http://www.xqsharp.com/raytracer/math" file="Demos/math.xq"/>
      <dependency type="spec" value="XQ10+"/> 
      <test><![CDATA[
        import module namespace raytracer="http://www.xqsharp.com/raytracer";
        import module namespace scene="http://www.xqsharp.com/raytracer/scene";
        declare variable $width := 64;
        declare variable $height := 64;
        declare variable $input-context := .;
        declare variable $scene := scene:prepare-scene($input-context/scene);
        string-join( ( "P3", string-join((string($width), string($height)), " "), "255", (: : Now the pixel data. We take each pixel in the image, and recenter it, so that the : y co-ordinate ($y-recentered) ranges from -0.5 at the bottom of the image, to 0.5 : at the top of the image. : : The aspect ratio is used to "stretch" the range of x-coordinate values to stop the : image from being skewed. :) 
        let $aspect-ratio := $width div $height 
        for $y in 1 to $height 
        let $y-recentered := ((-$y div $height) + 0.5) 
        for $x in 1 to $width 
        let $x-recentered := (($x div $width) - 0.5) * $aspect-ratio 
        return (: plot-pixel returns us the rgb values of the color of this pixel. 
        		  We convert these to an integer value in the range [0, 255], and output them. :) 
        	string-join( for $channel in raytracer:plot-pixel($scene, $x-recentered, $y-recentered) 
        			     return string(floor($channel * 255)), " ") ), "&#xA;" )
      ]]></test>
      <result>
         <all-of>
           <assert>starts-with(normalize-space(string-join($result, ' ')), 'P3 64 64 255 0 0 0')</assert>
           <assert>ends-with(normalize-space(string-join($result, ' ')), '125 119 179 125 118 178 124 118 177 124 117 176')</assert>
         </all-of>
      </result>
   </test-case>
   
   <test-case name="RexParser">
      <description>A parser written in XQuery generated using REx (Saxon bug 3260)</description>
      <created by="Michael Kay via Gunther Rademacher" on="2017-06-12"/>
      <dependency type="spec" value="XQ10+"/>
      <test file="Demos/RexParser.xq"/>
      <result>
         <all-of>
            <assert>every $i in (1,3,5,7,9,11) satisfies $result/self::S/*[$i][self::B[TOKEN='a']]</assert>
            <assert>every $i in (2,4,6,8,10,12) satisfies $result/self::S/*[$i][self::TOKEN='d']</assert>
            <assert>$result/self::S/*[13][self::EOF]</assert>
         </all-of>
      </result>
   </test-case>
</test-set>
