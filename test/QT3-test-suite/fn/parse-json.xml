<?xml version="1.0" encoding="UTF-8"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="fn-parse-json" covers="fn-parse-json">
   <description>
      Tests the parse-json function.
   </description>
   <link type="spec" document="http://www.w3.org/TR/xpath-functions-11/" idref="func-parse-json"/>
   <dependency type="spec" value="XP31+ XQ31+"/>
   
   <test-case name="fn-parse-json-001">
      <description>Empty object</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json("{}")</test>
      <result>
         <assert-deep-eq>map{}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-002">
      <description>Singleton object, numeric value</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="add test for redundant option"/>      
      <modified by="Christian Gruen" on="2015-01-31" change="Duplicate test element removed"/>
      <test>parse-json('{"abc":12}', map{'liberal':false()})</test>
      <result>
         <assert-deep-eq>map{"abc":12e0}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-003">
      <description>Singleton object, numeric value</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <test>parse-json('{"abc":12e0}')</test>
      <result>
         <assert-deep-eq>map{"abc":12e0}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-004">
      <description>Singleton object, negative numeric value</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <test>parse-json('{"abc":-1.2e0}')</test>
      <result>
         <assert-deep-eq>map{"abc":-1.2e0}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-005">
      <description>Singleton object, boolean value</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <test>parse-json('{"abc":true}')</test>
      <result>
         <assert-deep-eq>map{"abc":true()}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-006">
      <description>Singleton object, boolean value</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <test>parse-json('{"abc":false}')</test>
      <result>
         <assert-deep-eq>map{"abc":false()}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-007">
      <description>Singleton object, null value</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <test>parse-json('{"abc":null}')</test>
      <result>
         <assert-deep-eq>map{"abc":()}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-008">
      <description>Two-entry object</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <test>parse-json('{"abc":true,"xyz":false}')</test>
      <result>
         <assert-deep-eq>map{"abc":true(),"xyz":false()}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-009">
      <description>Two-entry object - same with whitespace</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <test>parse-json(' { "abc" : true , "xyz" : false } ')</test>
      <result>
         <assert-deep-eq>map{"abc":true(),"xyz":false()}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-010">
      <description>Two-entry object - same with more whitespace</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <test>parse-json('    {   "abc"   :   true    ,
            "xyz"   :   false   
            }   ')</test>
      <result>
         <assert-deep-eq>map{"abc":true(),"xyz":false()}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-011">
      <description>Empty array</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <test>parse-json("[]")</test>
      <result>
         <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>array:size($result) eq 0</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-012">
      <description>Single-item array</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <test>parse-json("[12345]")</test>
      <result>
         <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>$result?1 eq 12345</assert>
            <assert>array:size($result) eq 1</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-013">
      <description>Single-item array</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <test>parse-json('["abcd"]')</test>
      <result>
         <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>$result?1 eq "abcd"</assert>
            <assert>array:size($result) eq 1</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-014">
      <description>Single-item array</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <test>parse-json("[true]")</test>
      <result>
        <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>$result?1 eq true()</assert>
            <assert>array:size($result) eq 1</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-015">
      <description>Single-item array</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <test>parse-json("[false]")</test>
      <result>
         <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>$result?1 eq false()</assert>
            <assert>array:size($result) eq 1</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-016">
      <description>Single-item array</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <test>parse-json("[null]")</test>
      <result>
         <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>empty($result?1)</assert>
            <assert>array:size($result) eq 1</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-017">
      <description>Multi-item array</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <test>parse-json('[1,2,3, "abc", "def", true, false, null]')</test>
      <result>
        <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>array:size($result) eq 8</assert>
            <assert>$result?1 eq 1</assert>
            <assert>$result?2 eq 2</assert>
            <assert>$result?3 eq 3</assert>
            <assert>$result?4 eq "abc"</assert>
            <assert>$result?5 eq "def"</assert>
            <assert>$result?6 eq true()</assert>
            <assert>$result?7 eq false()</assert>
            <assert>$result?8 => empty()</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-018">
      <description>Multi-item array - same with more whitespace</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <test>parse-json('
        [   1,     2,  3, 
        "abc",  "def",   true, 
        false,  null ]
        ')</test>
      <result>
         <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>array:size($result) eq 8</assert>
            <assert>$result?1 eq 1</assert>
            <assert>$result?2 eq 2</assert>
            <assert>$result?3 eq 3</assert>
            <assert>$result?4 eq "abc"</assert>
            <assert>$result?5 eq "def"</assert>
            <assert>$result?6 eq true()</assert>
            <assert>$result?7 eq false()</assert>
            <assert>$result?8 => empty()</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-019">
      <description>Nested empty arrays</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json("[[[],[]]]")</test>
      <result>
        <all-of>
            <assert-type>array(array(array(*)))</assert-type>
            <assert-count>1</assert-count>
            <assert>array:size($result) eq 1</assert>
            <assert>array:size($result?1) eq 2</assert>
            <assert>array:size($result?1?2) eq 0</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-020">
      <description>Nested non-empty arrays</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('[1, 2, [], [1], [1,2], [1,2,3]]')</test>
      <result>        
         <all-of>
            <assert-type>array(*)</assert-type>
            <assert-count>1</assert-count>
            <assert>array:size($result) = 6</assert>
            <assert>$result?6?3 = 3</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-021">
      <description>Array of objects</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="return an array"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('[{"x":12,"y":5}, {"x":13,"y":6}]')</test>
      <result>
         <all-of>
           <assert>array:size($result) = 2</assert>
           <assert>$result?2?y = 6</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-022">
      <description>Object containing arrays</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('{"x":[12,3], "y":[14,9]}')</test>
      <result>
         <all-of>
           <assert>map:size($result) = 2</assert>
           <assert>$result?y?2 = 9</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-023">
      <description>Number formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('[0.123]')</test>
      <result>
         <all-of>
           <assert>$result?1 = 0.123e0</assert>
           <assert>$result?1 instance of xs:double</assert>
         </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-024">
      <description>Number formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('[-0.123]')</test>
      <result>
         <all-of><assert>$result?1 = -0.123e0</assert>
         <assert>$result?1 instance of xs:double</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-025">
      <description>Number formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('[-0.123e2]')</test>
      <result>
         <all-of><assert>$result?1 = -0.123e2</assert>
         <assert>$result?1 instance of xs:double</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-026">
      <description>Number formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('[-0.123e+2]')</test>
      <result>
         <all-of><assert>$result?1 = -0.123e+2</assert>
         <assert>$result?1 instance of xs:double</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-027">
      <description>Number formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('[-0.123e-2]')</test>
      <result>
         <all-of><assert>$result?1 = -0.123e-2</assert>
         <assert>$result?1 instance of xs:double</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-028">
      <description>String formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\\"]')</test>
      <result>
         <all-of><assert>$result?1 = "\"</assert>
         <assert>$result?1 instance of xs:string</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-029">
      <description>String formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\""]')</test>
      <result>
         <all-of><assert>$result?1 = '"'</assert>
         <assert>$result?1 instance of xs:string</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-030">
      <description>String formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Christian Gruen" on="2015-01-31" change="Additional encoding of entity"/>
      <modified by="Michael Kay" on="2015-03-11" change="Avoid using character reference, so the assertion works in both XPath and XQuery"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\r"]')</test>
      <result>
         <all-of><assert>$result?1 = codepoints-to-string(13)</assert>
         <assert>$result?1 instance of xs:string</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-031">
      <description>String formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Christian Gruen" on="2015-01-31" change="Additional encoding of entity"/>
      <modified by="Michael Kay" on="2015-03-11" change="Avoid using character reference, so the assertion works in both XPath and XQuery"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\n"]')</test>
      <result>
         <all-of><assert>$result?1 = codepoints-to-string(10)</assert>
         <assert>$result?1 instance of xs:string</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-032">
      <description>String formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\/"]')</test>
      <result>
         <all-of><assert>$result?1 = '/'</assert>
         <assert>$result?1 instance of xs:string</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-033">
      <description>String formats</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["aa\u0030aa"]')</test>
      <result>
         <all-of><assert>$result?1 = 'aa0aa'</assert>
         <assert>$result?1 instance of xs:string</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-034">
      <description>String formats - surrogate pair</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay" on="2015-03-11" change="Avoid using character reference, so the assertion works in both XPath and XQuery"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\uD834\udD1E"]')</test>
      <result>
         <all-of><assert>$result?1 = codepoints-to-string(119070)</assert>
         <assert>$result?1 instance of xs:string</assert></all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-035">
      <description>String formats: effect of escape option</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Michael Kay" on="2015-07-17" change="Change keyword unescape->escape"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\r"]', map{'escape':true()})</test>
      <result>
         <assert>$result?1 = '\r'</assert>
      </result>
   </test-case>
   <test-case name="fn-parse-json-036">
      <description>String formats: effect of escape option</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Christian Gruen" on="2015-01-31" change="Additional encoding of entity"/>
      <modified by="Michael Kay" on="2015-03-11" change="Avoid using character reference, so the assertion works in both XPath and XQuery"/>
      <modified by="Michael Kay" on="2015-07-17" change="Change keyword unescape->escape"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\r"]', map{'escape':false()})</test>
      <result>
         <assert>$result?1 = codepoints-to-string(13)</assert>
      </result>
   </test-case>
   <test-case name="fn-parse-json-037">
      <description>String formats: effect of escape option</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Michael Kay" on="2015-07-17" change="Change keyword unescape->escape"/>
      <modified by="Michael Kay, Saxonica" on="2015-11-26" change="avoid HOF dependency in assertions"/>
      <test>parse-json('["\u0000"]', map{'escape':true()})</test>
      <result>
         <assert>$result?1 = '\u0000'</assert>
      </result>
   </test-case>
   <test-case name="fn-parse-json-038">
      <description>Anything allowed at Top level under ECMA spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="'spec' option has been dropped from the spec"/>
      <test>parse-json('true')</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-039">
      <description>Anything allowed at Top level under ECMA spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="'spec' option has been dropped from the spec"/>
      <test>parse-json('false')</test>
      <result>
         <assert-false/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-040">
      <description>Anything allowed at Top level under ECMA spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="'spec' option has been dropped from the spec"/>
      <test>parse-json('null')</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-041">
      <description>Anything allowed at Top level under ECMA spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="'spec' option has been dropped from the spec"/>
      <test>parse-json('93.7')</test>
      <result>
        <all-of>
          <assert-eq>93.7e0</assert-eq>
          <assert-type>xs:double</assert-type>
        </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-042">
      <description>Anything allowed at Top level under ECMA spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Michael Kay, Saxonica" on="2015-01-30" change="'spec' option has been dropped from the spec"/>
      <modified by="Michael Kay" on="2015-07-17" change="Change keyword unescape->escape"/>
      <test>parse-json('"abcd\n"', map{'escape':true()})</test>
      <result>
        <all-of>
          <assert-eq>'abcd\n'</assert-eq>
          <assert-type>xs:string</assert-type>
        </all-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-050">
      <description>Duplicate keys - use first</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('{"a":1, "b":2, "a":3}', map{'duplicates':'use-first'})</test>
      <result>
        <assert-deep-eq>map{"a":1, "b":2}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-051">
      <description>Duplicate keys - use last</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('{"a":1, "b":2, "a":3}', map{'duplicates':'use-last'})</test>
      <result>
        <assert-deep-eq>map{"a":3, "b":2}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-052">
      <description>Duplicate keys - default</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <modified by="Josh Spiegel" on="2015-06-17" change="Bug 28771 changes the default for duplicates to use-first"/>
      <test>parse-json('{"a":1, "b":2, "a":3}', map{})</test>
      <result>
        <assert-deep-eq>map{"a":1, "b":2}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-053">
      <description>Invalid XML char, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <test>parse-json('"\uFFFF"')</test>
      <result>
        <assert-eq>codepoints-to-string(65533)</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-054">
      <description>Unpaired surrogate, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <test>parse-json('"\uDEAD"')</test>
      <result>
        <assert-eq>codepoints-to-string(65533)</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-055">
      <description>Character not in XML 1.0, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <dependency type="xml-version" value="1.0"/>
      <test>parse-json('"\b"')</test>
      <result>
        <assert-eq>codepoints-to-string(65533)</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-056">
      <description>Invalid XML char, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>parse-json('{"\uFFFF":""}') => map:keys()</test>
      <result>
        <assert-eq>codepoints-to-string(65533)</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-057">
      <description>Unpaired surrogate, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>parse-json('{"\uDEAD":""}') => map:keys()</test>
      <result>
        <assert-eq>codepoints-to-string(65533)</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-058">
      <description>Character not in XML 1.0, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="xml-version" value="1.0"/>
      <test>parse-json('{"\b":""}') => map:keys()</test>
      <result>
        <assert-eq>codepoints-to-string(65533)</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-059">
      <description>Invalid XML char, fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('"\uFFFF"', map{'fallback':lower-case#1})</test>
      <result>
        <assert-eq>"\uffff"</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-060">
      <description>Unpaired surrogate, fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('"\uDEAD"', map{'fallback':lower-case#1})</test>
      <result>
        <assert-eq>"\udead"</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-061">
      <description>Character not in XML 1.0, fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="Debbie Lockett" on="2015-08-07" change="Add alternate result"/>
      <dependency type="xml-version" value="1.0"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('"\b"', map{'fallback':lower-case#1})</test>
      <result>
         <any-of>
            <assert-eq>"\b"</assert-eq>
            <assert-eq>"\u0008"</assert-eq>
         </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-062">
      <description>Invalid XML char, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('{"\uFFFF":""}', map{'fallback':lower-case#1}) => map:keys()</test>
      <result>
        <assert-eq>"\uffff"</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-063">
      <description>Unpaired surrogate, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('{"\uDEAD":""}', map{'fallback':lower-case#1}) => map:keys()</test>
      <result>
        <assert-eq>"\udead"</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-064">
      <description>Character not in XML 1.0, no fallback</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="Debbie Lockett" on="2015-08-07" change="Add alternate result"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="xml-version" value="1.0"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('{"\b":""}', map{'fallback':lower-case#1}) => map:keys()</test>
      <result>         
         <any-of>
            <assert-eq>"\b"</assert-eq>
            <assert-eq>"\u0008"</assert-eq>
         </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-065">
      <description>Ignore 'validate' option parameter</description>
      <created by="Debbie Lockett, Saxonica" on="2015-06-17"/>
      <test>parse-json('{"a":1, "b":2}', map{'validate':true()})</test>
      <result>
         <assert-deep-eq>map{"a":1, "b":2}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-066">
      <description>Use last</description>
      <created by="Josh Spiegel" on="2015-08-01"/>
      <test>
        parse-json('
          {
             "x" : [1,2,[]],
             "y" : { "a" : {} },
             "x" : [3,4,[]],
             "y" : { "c" : [], "c" : 1, "c" : {} }
          }
        ',
        map{'duplicates':'use-last'})
      </test>
      <result>
         <assert-deep-eq>map{"x":[3,4,[]], "y":map{"c" : map{}}}</assert-deep-eq>
      </result>
   </test-case>   
   
   
   <!-- "real" JSON files -->
   
   <test-case name="fn-parse-json-101">
      <description>An example JSON file</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json(unparsed-text('parse-json/data001.json'))</test>
      <result>
         <assert-count>1</assert-count>
      </result>
   </test-case>
   <test-case name="fn-parse-json-102">
      <description>An example JSON file</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json(unparsed-text('parse-json/data002.json'))</test>
      <result>
         <assert-count>1</assert-count>
      </result>
   </test-case>
   <test-case name="fn-parse-json-103">
      <description>An example JSON file</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json(unparsed-text('parse-json/data003.json'))</test>
      <result>
         <assert-count>1</assert-count>
      </result>
   </test-case>
   <test-case name="fn-parse-json-104">
      <description>An example JSON file</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json(unparsed-text('parse-json/data004.json'))</test>
      <result>
         <assert-count>1</assert-count>
      </result>
   </test-case>
   <test-case name="fn-parse-json-105">
      <description>An example JSON file</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json(unparsed-text('parse-json/data005.json'))</test>
      <result>
         <assert-count>1</assert-count>
      </result>
   </test-case>
   <test-case name="fn-parse-json-106">
      <description>
         If the escape option is set to true, escape sequences are used only for special characters.
      </description>
      <created by="Michael Kay" on="2016-09-23"/>
      <modified by="Michael Kay" on="2016-10-04" change="see reopening of bug 28812"/>
      <test>parse-json('{"x":"\\", "y":"\u0025"}', map{'escape':true()})</test>
      <result>
         <assert-deep-eq>map{"x":"\\","y":"%"}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-107">
      <description>
         If the escape option is set to true, escape sequences are used only for special characters.
      </description>
      <created by="Michael Kay" on="2016-09-29"/>
      <modified by="Michael Kay" on="2016-10-04" change="see reopening of bug 28812"/>
      <test>parse-json('{"\\":"x", "\u0025":"y"}', map{'escape':true()})</test>
      <result>
         <assert-deep-eq>map{"\\":"x", "%":"y"}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-108">
      <description>
         If the escape option is set to true, keys are compared in their escaped form
         when testing for duplicates.
      </description>
      <created by="Michael Kay" on="2016-09-29"/>
      <modified by="Michael Kay" on="2016-10-04" change="see reopening of bug 28812"/>
      <test>parse-json('{"%":"x", "\u0025":"y"}', map{'escape':true(), 'duplicates':'reject'})</test>
      <result>
         <error code="FOJS0003"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-109">
      <description>
         If the escape option is set to true, keys are compared in their escaped form
         when testing for duplicates.
      </description>
      <created by="Michael Kay" on="2016-09-29"/>
      <test>parse-json('{"/":"x", "\/":"y"}', map{'escape':true(), 'duplicates':'reject'})</test>
      <result>
         <error code="FOJS0003"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-110">
      <description>
         If the escape option is set to true, keys are compared in their escaped form
         when testing for duplicates.
      </description>
      <created by="Michael Kay" on="2016-09-29"/>
      <modified by="Michael Kay" on="2016-10-21" change="see bug29934"/>
      <test>parse-json('{"\u000a\u0025":"x", "\n%":"y"}', map{'escape':true(), 'duplicates':'reject'})</test>
      <result>
         <error code="FOJS0003"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-111">
      <description>
         If the escape option is set to true, keys are compared in their escaped form
         when testing for duplicates.
      </description>
      <created by="Michael Kay" on="2016-09-29"/>
      <test>parse-json('{"%\u0010%":"x", "%\n%":"y"}', map{'escape':true(), 'duplicates':'reject'})</test>
      <result>
         <assert-deep-eq>map{"%\u0010%":"x", "%\n%":"y"}</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-112">
      <description>
         Arity=1, empty sequence as first argument
      </description>
      <created by="Michael Kay" on="2018-06-08"/>
      <test>parse-json(())</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-113">
      <description>
         Arity=2, empty sequence as first argument
      </description>
      <created by="Michael Kay" on="2018-06-08"/>
      <test>parse-json((),  map{'escape':true(), 'duplicates':'reject'})</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-114">
      <description>
         Arity=1, dynamic empty sequence as first argument
      </description>
      <created by="Michael Kay" on="2018-07-18"/>
      <test>parse-json("[]"[current-date() lt xs:date('1900-01-01')])</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-115">
      <description>
         Arity=2, dynamic empty sequence as first argument
      </description>
      <created by="Michael Kay" on="2018-07-18"/>
      <test>parse-json("[]"[current-date() lt xs:date('1900-01-01')],  map{'escape':true(), 'duplicates':'reject'})</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
  
   <!-- things that a liberal parser might allow -->

   <test-case name="fn-parse-json-801">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[-0.123e-2,]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-802">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[FALSE]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-804">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[(5)]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-806">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[{x:23}]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-809">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[1,2,3,]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-810">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('{"a":=13}', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-811">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('{"a":13,,"b":15}', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-814">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('{"a":{"b":12}}}', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-815">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('["\"]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-816">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('["\1"]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-817">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('["\u2"]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-819">
      <description>Syntax error: invalid character under XML 1.0</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <dependency type="xml-version" value="1.0"/>
      <test>parse-json('["\b"]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-820">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('["\x20"]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-821">
      <description>String formats: \s is not allowed by the RFC</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('["\s"]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-822">
      <description>String formats - unpaired surrogate</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('["\uD834"]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-823">
      <description>String formats - surrogate pair</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('["\udD1E"]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-824">
      <description>String formats: effect of escape option: invalid XML character</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <modified by="Michael Kay" on="2015-07-17" change="Change keyword unescape->escape"/>
      <test>parse-json('["\u0000"]', map{'escape':false(), 'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-830">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[.3]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-831">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[01]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-832">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[00.00]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-833">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[+23]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-834">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('[1.234f0]', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-835">
      <description>Wrong quote mark</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json("['wrong']", map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-839">
      <description>Empty input</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('', map{'liberal':true()})</test>
      <result>
        <any-of>
          <assert-type>item()?</assert-type>
          <error code="FOJS0001"/>
        </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-840">
      <description>
         Raw unescaped control characters are not allowed in JSON input.
      </description>
      <created by="Michael Kay" on="2016-10-21"/>
      <test>parse-json('{"'||codepoints-to-string((10, 37))||'":"x", "yyy":"y"}', map{'liberal':true()})</test>
      <result>
         <any-of>
            <assert-type>item()?</assert-type>
            <error code="FOJS0001"/>
         </any-of>
      </result>
   </test-case>
    
   <!-- error cases -->
   
   <test-case name="fn-parse-json-901">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[-0.123e-2[')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-902">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[false')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-903">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[falsehood]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-904">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[(5)]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-905">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[{5}]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-906">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[{x:23}]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-907">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('23,24')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-908">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('["abc]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-909">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[1,2,3,]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-910">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('{"a":=13}')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-911">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('{"a":13,,"b":15}')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-912">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('{"a":13')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-913">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('{"a":{"b":12}')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-914">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('{"a":{"b":12}}}')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-915">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('["\"]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-916">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('["\1"]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-917">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('["\u2"]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-918">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('["\u123u"]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-919">
      <description>Syntax error: invalid character under XML 1.0</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Christian Gruen" on="2015-01-31" change="Encode as xFFFD"/>
     <dependency type="xml-version" value="1.0"/>
      <test>parse-json('["\b"]')</test>
      <result>
         <any-of>
            <assert-deep-eq>['&#xFFFD;']</assert-deep-eq>
            <error code="FOJS0001"/>
         </any-of>
      </result>
   </test-case>
   <test-case name="fn-parse-json-920">
      <description>Syntax error</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('["\x20"]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-921">
      <description>String formats: \s is not allowed by the RFC</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('["\s"]')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-922">
      <description>String formats - unpaired surrogate</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Christian Gruen" on="2015-01-31" change="Encode as xFFFD"/>
      <modified by="Tim Mills" on="2016-07-29" change="Bug 29759"/>
      <test>parse-json('["\uD834"]')</test>
      <result>
            <assert-deep-eq>['&#xFFFD;']</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-923">
      <description>String formats - surrogate pair</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Christian Gruen" on="2015-01-31" change="Encode as xFFFD"/>
      <modified by="Tim Mills" on="2016-07-29" change="Bug 29759"/>
      <test>parse-json('["\udD1E"]')</test>
      <result>
            <assert-deep-eq>['&#xFFFD;']</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-924">
      <description>String formats: effect of escape option: invalid XML character</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Christian Gruen" on="2015-01-31" change="Encode as xFFFD"/>
      <modified by="Michael Kay" on="2015-07-17" change="Change keyword unescape->escape"/>
      <modified by="Tim Mills" on="2016-07-29" change="Bug 29759"/>
      <test>parse-json('["\u0000"]', map{'escape':false()})</test>
      <result>
            <assert-deep-eq>['&#xFFFD;']</assert-deep-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-925">
      <description>Anything not allowed at Top level under RFC spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Michael Kay" on="2015-03-11" change="RFC4627 resctriction no longer applies; and 'spec' options should be ignored"/>
      <test>parse-json('true', map{'spec':'RFC4627'})</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-926">
      <description>Anything not allowed at Top level under RFC spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Michael Kay" on="2015-03-11" change="RFC4627 resctriction no longer applies; and 'spec' options should be ignored"/>
      <test>parse-json('false', map{'spec':'RFC4627'})</test>
      <result>
         <assert-false/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-927">
      <description>Anything not allowed at Top level under RFC spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Michael Kay" on="2015-03-11" change="RFC4627 resctriction no longer applies; and 'spec' options should be ignored"/>
      <test>parse-json('null', map{'spec':'RFC4627'})</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-928">
      <description>Anything not allowed at Top level under RFC spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Michael Kay" on="2015-03-11" change="RFC4627 resctriction no longer applies; and 'spec' options should be ignored"/>
      <test>parse-json('93.7', map{'spec':'RFC4627'})</test>
      <result>
        <assert-eq>93.7</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-929">
      <description>Anything not allowed at Top level under RFC spec</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <modified by="Josh Spiegel" on="2015-01-21" change="Fix map constructor syntax"/>
      <modified by="Michael Kay" on="2015-03-11" change="RFC4627 resctriction no longer applies; and 'spec' options should be ignored"/>
      <modified by="Michael Kay" on="2015-07-17" change="Change keyword unescape->escape"/>
      <test>parse-json('"abcd\n"', map{'spec':'RFC4627','escape':true()})</test>
      <result>
        <assert-eq>'abcd\n'</assert-eq>
      </result>
   </test-case>
   <test-case name="fn-parse-json-930">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[.3]')</test>
      <result>
        <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-931">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[01]')</test>
      <result>
        <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-932">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[00.00]')</test>
      <result>
        <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-933">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[+23]')</test>
      <result>
        <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-934">
      <description>Invalid number</description>
      <created by="Michael Kay, Saxonica" on="2011-03-31"/>
      <test>parse-json('[1.234f0]')</test>
      <result>
        <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-935">
      <description>Wrong quote mark</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json("['wrong']")</test>
      <result>
        <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-936">
      <description>Duplicate keys</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('{"a":1, "b":2, "a":3}', map{'duplicates':'reject'})</test>
      <result>
        <error code="FOJS0003"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-937">
      <description>Bad option value (see bug 27930)</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <modified by="Michael Kay, Saxonica" on="2015-03-11" change="change error code"/>
      <test>parse-json('{"a":1, "b":2, "a":3}', map{'duplicates':'do-your-own-thing'})</test>
      <result>
        <error code="FOJS0005"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-938">
      <description>Bad option value (see bug 27930)</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <modified by="Michael Kay, Saxonica" on="2015-03-11" change="change error code"/>
      <modified by="Debbie Lockett" on="2015-08-04" change="Error code change for bug 28994"/>
      <test>parse-json('{"a":1, "b":2, "c":3}', map{'liberal':'liberal'})</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-939">
      <description>Empty input</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <test>parse-json('')</test>
      <result>
        <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-940">
      <description>Bad option value (see bug 27930)</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <test>parse-json('{"a":1, "b":2, "a":3}', map{'duplicates':'retain'})</test>
      <result>
        <error code="FOJS0005"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-941">
      <description>Fallback is not a function</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="Debbie Lockett" on="2015-08-04" change="Error code change for bug 28994"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="xml-version" value="1.0"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('{"\b":""}', map{'fallback':lower-case('a')}) => map:keys()</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-942">
      <description>Fallback is a function with wrong arity</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="Debbie Lockett" on="2015-08-04" change="Error code change for bug 28994"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="xml-version" value="1.0"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('{"\b":""}', map{'fallback':substring#2}) => map:keys()</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-943">
      <description>Fallback throws an error</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="xml-version" value="1.0"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('{"\b":""}', map{'fallback':error(QName("","USER9999"), ?)}) => map:keys()</test>
      <result>
        <error code="Q{}USER9999"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-944">
      <description>Fallback is not called for invalid escape sequences</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('{"\xaa":""}', map{'fallback':upper-case#1}) => map:keys()</test>
      <result>
        <error code="FOJS0001"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-945">
      <description>Fallback function does not accept a string (Note: awaits outcome of bug 28196)</description>
      <created by="Michael Kay, Saxonica" on="2015-03-11"/>
      <modified by="Debbie Lockett" on="2015-08-04" change="Error code change for bug 28994"/>
      <modified by="O'Neil Delpratt" on="2016-02-01" change="Bug fix #29412: Removed XT30+ dependency."/>
      <environment ref="map" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>parse-json('{"\uFFFF":""}', map{'fallback':abs#1}) => map:keys()</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   <test-case name="fn-parse-json-946">
      <description>Option values are implicitly atomized</description>
      <created by="Michael Kay, Saxonica" on="2015-01-30"/>
      <modified by="Josh Spiegel" on="2015-06-17" change="Updated result, value should be atomized (Bug 28196)"/>
      <dependency type="spec" value="XQ31+"/>
      <test><![CDATA[parse-json('{"a":1, "b":2}', map{'duplicates':<a>use-first</a>})]]></test>
      <result>
        <assert-deep-eq>map{"a":1, "b":2}</assert-deep-eq>
      </result>
   </test-case>

   <test-case name="fn-parse-json-947">
      <description>Syntax error</description>
      <created by="Tim Mills" on="2016-06-03"/>
      <dependency type="spec" value="XQ31+"/>
      <test>parse-json('{"a" "b"}')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>

   <test-case name="fn-parse-json-948">
      <description>Syntax error</description>
      <created by="Tim Mills" on="2016-06-03"/>
      <dependency type="spec" value="XQ31+"/>
      <test>parse-json('{"a"')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>

   <test-case name="fn-parse-json-949">
      <description>Syntax error</description>
      <created by="Tim Mills" on="2016-06-03"/>
      <dependency type="spec" value="XQ31+"/>
      <test>parse-json('314eg')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>

   <test-case name="fn-parse-json-950">
      <description>Syntax error</description>
      <created by="Tim Mills" on="2016-06-03"/>
      <dependency type="spec" value="XQ31+"/>
      <test>parse-json('3.14eg')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>

   <test-case name="fn-parse-json-951">
      <description>Syntax error</description>
      <created by="Tim Mills" on="2016-06-03"/>
      <dependency type="spec" value="XQ31+"/>
      <test>parse-json('3.14Eg')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>

   <test-case name="fn-parse-json-952">
      <description>Syntax error</description>
      <created by="Tim Mills" on="2016-06-03"/>
      <dependency type="spec" value="XQ31+"/>
      <test>parse-json('3.14Eg')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   
   <test-case name="fn-parse-json-953">
      <description>
         Raw unescaped control characters are not allowed in JSON input.
      </description>
      <created by="Michael Kay" on="2016-10-21"/>
      <test>parse-json('{"'||codepoints-to-string((10, 37))||'":"x", "yyy":"y"}')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   
   <test-case name="fn-parse-json-954">
      <description>
         Unescaped backslash is not allowed in JSON input.
      </description>
      <created by="Michael Kay" on="2016-10-21"/>
      <test>parse-json('"aaa\"')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>
   
   <test-case name="fn-parse-json-955">
      <description>
         Unescaped backslash is not allowed in JSON input.
      </description>
      <created by="Michael Kay" on="2016-10-21"/>
      <test>parse-json('"111\333"')</test>
      <result>
         <error code="FOJS0001"/>
      </result>
   </test-case>

</test-set>
