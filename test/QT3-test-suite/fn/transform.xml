<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="fn-transform" covers="fn-transform">
   <description/>
   <link type="spec" document="http://www.w3.org/TR/xpath-functions-31/"
         idref="func-transform"/>

    <dependency type="spec" value="XQ31+ XP31+"/>

   <environment name="works-mod-uri2">
      <source role="." file="../docs/works-mod.xml" uri="http://www.w3.org/fots/docs/works-mod.xml">
         <description>Data for various NIST tests (abbreviated, unabbreviated syntax)</description>
         <created by="Carmelo Montanez" on="2005-03-04"/>
      </source>
      <source file="transform/render.xsl" uri="http://www.w3.org/fots/fn/transform/render.xsl">
         <description>Stylesheet</description>
         <created by="O'Neil Delpratt" on="2014-12-09"/>
      </source>
      <param name="uri" as="xs:string" select="'http://www.w3.org/fots/docs/works-mod.xml'" declared="false"/>
      <param name="render" as="xs:string" select="'http://www.w3.org/fots/fn/transform/render.xsl'" declared="false"/>
      <param name="base-uri" as="xs:string" select="'http://www.w3.org/fots/fn/transform/output-doc.xml'" declared="false"/>
   </environment>
    
    <environment name="works-mod-local">
        <source role="$works" file="../docs/works-mod.xml">
            <description>Data for various NIST tests (abbreviated, unabbreviated syntax)</description>
            <created by="Carmelo Montanez" on="2005-03-04"/>
        </source>        
        <source role="$render" file="transform/render.xsl">
            <description>Stylesheet</description>
            <created by="O'Neil Delpratt" on="2014-12-09"/>
        </source>
        <source role="$include" file="transform/include.xsl">
            <description>Stylesheet</description>
            <created by="Debbie Lockett" on="2015-03-09"/>
        </source>
    </environment>   

   <environment name="variable-uri">
      <source role="." file="transform/variable.xsl" uri="http://www.w3.org/fots/fn/transform/variable.xsl">
         <description>Stylesheet</description>
         <created by="O'Neil Delpratt" on="2014-12-09"/>
      </source>
      <param name="variable-uri" as="xs:string" select="'http://www.w3.org/fots/fn/transform/variable.xsl'" declared="false"/>
   </environment>
    
    <environment name="variable-with-context">
        <source role="$stylesheet" file="transform/variable-with-context.xsl">
            <description>Stylesheet</description>
            <created by="Michael Kay" on="2017-09-07"/>
        </source>
    </environment>
    
    <environment name="multiple-result-docs">
        <source role="$multipledocs" file="transform/multipledocs.xsl"/>
        <source role="$sections" file="transform/sections.xml"/>
        <namespace prefix="map" uri="http://www.w3.org/2005/xpath-functions/map"/>
    </environment>
    
    

    <test-case name="fn-transform-1">
      <description>Loads a stylesheet from the location render.xsl, applies it to a document loaded from works-mod.xml, and uses an XPath expression to examine the result</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
      <modified by="Debbie Lockett" on="2015-03-05" change="Rename stylesheet-uri as stylesheet-location"/>
      <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
      <environment ref="works-mod-uri2"/>
      <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri)})return $result?output</test>
      <result>
         <assert>count($result//employee) > 0</assert>
      </result>
   </test-case>

    <test-case name="fn-transform-1a">
      <description>Loads a stylesheet from the location render.xsl, applies it to a document loaded from works-mod.xml. Delivery format set to xs:string</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
      <modified by="Michael Kay" on="2015-01-03" change="change 'castable as' to 'instance of'"/>
      <modified by="Debbie Lockett" on="2015-03-05" change="Rename stylesheet-uri as stylesheet-location"/>
      <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
      <environment ref="works-mod-uri2"/>
      <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized"})return $result?output instance of xs:string</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="fn-transform-1b">
      <description>Loads a stylesheet from the location render.xsl, applies it to a document loaded from works-mod.xml. Delivery format set to document node (the default)</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
      <modified by="Michael Kay" on="2015-01-03" change="change 'castable as' to 'instance of'"/>
       <modified by="Debbie Lockett" on="2015-03-05" change="Rename stylesheet-uri as stylesheet-location"/>
      <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
      <environment ref="works-mod-uri2"/>
       <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "document"})return $result?output instance of node()</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

    <test-case name="fn-transform-1c">
      <description>Same as fn-transform-1 with XP30 syntax</description>
      <created by="Abel Braaksma" on="2016-09-22"/>
      <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
      <environment ref="works-mod-uri2"/>
      <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri)})return $result("output")</test>
      <result>
         <assert>count($result//employee) > 0</assert>
      </result>
   </test-case>

    <test-case name="fn-transform-1d">
      <description>Same as fn-transform-1a with XP30 syntax</description>
      <created by="Abel Braaksma" on="2016-09-22"/>
      <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
      <environment ref="works-mod-uri2"/>
      <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized"})return $result("output") instance of xs:string</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="fn-transform-1e">
      <description>Same as fn-transform-1b with XP30 syntax</description>
      <created by="Abel Braaksma" on="2016-09-22"/>
      <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
      <environment ref="works-mod-uri2"/>
       <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "document"})return $result("output") instance of node()</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
    <test-case name="fn-transform-2">
        <description>This test case demonstrates the ability to retrieve multiple result documents. Transform depends on XSLT 3.0 processor</description>
        <created by="O'Neil Delpratt" on="2014-12-09"/>
        <modified by="Debbie Lockett" on="2015-03-05" change="Fix options xslt-version and initial-template, typos in stylesheet, return statement and assertion"/>
        <modified by="Debbie Lockett" on="2015-04-13" change="Add base-output-uri option"/>
        <modified by="Michael Kay" on="2015-11-27" change="Add dependency on XSLT 3.0"/>
        <modified by="Tim Mills" on="2016-10-25" change="Bug 29942"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <modified by="Michael Kay" on="2018-06-14" change="Formatted for readability"/>
        <dependency type="spec" value="XQ31+"/>
	<dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test>
            <![CDATA[
                    let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'
                                                                 xmlns:app='http://www.example.com'>
                                    <xsl:template name='app:main'> 
                                       <xsl:for-each select='//section'>
                                          <xsl:result-document href='section{position()}.html'>
                                             <xsl:value-of select='.' />
                                          </xsl:result-document>
                                       </xsl:for-each>
                                    </xsl:template> 
                                 </xsl:stylesheet>",
                        $xml := "<doc>
                                   <section>sect1</section>
                                   <section>sect2</section>
                                 </doc>"
                    return
                    element {xs:QName('html')} {
                        element {xs:QName('body')} {
                            for $x in fn:transform(
                                        map{"xslt-version"    : 2.0, 
                                            "stylesheet-text" : $xsl,
                                            "base-output-uri" : "http://www.w3.org/fots/fn/transform/output-doc.xml",
                                            "initial-template": fn:QName('http://www.example.com','main'), 
                                            "source-node"     : fn:parse-xml($xml)})?*
                            return $x }
                        }]]>
        </test>
        <result>
           <assert>contains(string($result//body),'sect2')</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-3">
        <description>Use of stylesheet-params option</description>
        <created by="O'Neil Delpratt" on="2014-12-09"/>
        <modified by="Debbie Lockett" on="2015-03-05" change="Fix variable $in, use of fn:QName(), and result assertions; and change test-case description"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, there is no XQ31 specific syntax"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
	    <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="variable-uri"/>
        <test>
            <![CDATA[
                    let $in := parse-xml("<dummy/>"),
                        $style := doc($variable-uri) return (
                    transform(map{"source-node":$in, "stylesheet-node":$style, "stylesheet-params": map { QName("","v"): "2" } } ) )?output
                        ]]>
        </test>
        <result>
            <all-of>
                <assert>$result instance of node()</assert>
                <assert-xml><![CDATA[<v>2</v>]]></assert-xml>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-3a">
        <description>Same as fn-transform-3 with XP30 syntax</description>
        <created by="Abel Braaksma" on="2016-09-22"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
    	<dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="variable-uri"/>
        <test>
            <![CDATA[
                    let $in := parse-xml("<dummy/>"),
                        $style := doc($variable-uri) return (
                    transform(map{"source-node":$in, "stylesheet-node":$style, "stylesheet-params": map { QName("","v"): "2" } } ) )("output")
                        ]]>
        </test>
        <result>
            <all-of>
                <assert>$result instance of node()</assert>
                <assert-xml><![CDATA[<v>2</v>]]></assert-xml>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-4">
        <description>Outputs the result as html, use of serialization-params</description>
        <created by="O'Neil Delpratt" on="2014-12-09"/>
        <modified by="Debbie Lockett" on="2015-03-05" change="Fix stylesheet, use of fn:QName(), and result assertion"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-10-19" change="Bug 29440/29443: serialization params aligned with fn:serialize()"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test>
            <![CDATA[
                    let $in := xs:string("<books>
    <book>
        <title>XSLT Programmer?s Reference</title>
        <author>Michael H. Kay</author>
    </book>
    <book>
        <title>XSLT</title>
        <author>Doug Tidwell</author>
        <author>Simon St. Laurent</author>
        <author>Robert Romano</author>
    </book>
</books>"),
         $style := xs:string('<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="html"/>
    <xsl:template match="/">
        <html>
            <body>
                <div>
                    <xsl:for-each select="books/book">
                        <b><xsl:value-of select="title"/></b>: <xsl:value-of select="author"
                        /><br/>
                    </xsl:for-each>
                </div>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>')
return transform(map{"source-node":fn:parse-xml($in), "stylesheet-text":$style, "serialization-params": map{"indent": true()} } )("output")]]>
        </test>
        <result>
            <assert>$result//b = 'XSLT'</assert>
        </result>
    </test-case>


    <test-case name="fn-transform-5">
        <description>Outputs the result as html; input source and stylesheet as strings</description>
        <created by="Debbie Lockett" on="2015-03-05"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test>
            <![CDATA[
                    let $in := xs:string("<books>
    <book>
        <title>XSLT Programmer?s Reference</title>
        <author>Michael H. Kay</author>
    </book>
    <book>
        <title>XSLT</title>
        <author>Doug Tidwell</author>
        <author>Simon St. Laurent</author>
        <author>Robert Romano</author>
    </book>
</books>"),
   $style := xs:string('<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="html"/>
    <xsl:template match="/">
        <html>
            <body>
                <div>
                    <xsl:for-each select="books/book">
                        <b><xsl:value-of select="title"/></b>: <xsl:value-of select="author"
                        />
                    </xsl:for-each>
                </div>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>')
return transform(map{"source-node":fn:parse-xml($in), "stylesheet-text":$style } )("output")]]>
        </test>
        <result>
            <assert>$result//b = 'XSLT'</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-6">
        <description>Transform with minimal options: stylesheet-text, source-node</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>") })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result?output instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-7">
        <description>Transform with minimal options: stylesheet-node, source-node</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-node":parse-xml($xsl), "source-node":parse-xml("<doc>this</doc>") })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result?output instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-8">
        <description>Transform with minimal options: stylesheet-node, source-node</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            transform(map{"stylesheet-node":fn:parse-xml("<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"), "source-node":parse-xml("<doc>this</doc>") })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result("output")//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-9">
        <description>Transform using option initial-template</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template name='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "initial-template": fn:QName('','main') })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result?output instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-10">
        <description>Transform using option initial-template</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'
            xmlns:app='http://www.example.com'>
            <xsl:template match='/'>
                <x><xsl:value-of select='.' /></x>
            </xsl:template>
                <xsl:template name='app:main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "initial-template": fn:QName('http://www.example.com','main') })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result?output instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-11">
        <description>Transform using option initial-template, without source-node</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'
            xmlns:app='http://www.example.com'>
            <xsl:template match='/'>
                <x><xsl:value-of select='.' /></x>
            </xsl:template>
                <xsl:template name='app:main'>
                    <out>that</out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "initial-template": fn:QName('http://www.example.com','main') })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result?output instance of node()</assert>
                <assert>$result?output//out = 'that'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-12">
        <description>Transform using option initial-mode</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
            <xsl:template match='/'>
                <x><xsl:value-of select='.' /></x>
            </xsl:template>
                <xsl:template match='/' mode='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "initial-mode": fn:QName('','main') })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result?output instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-13">
        <description>Transform producing multiple result documents</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <modified by="Debbie Lockett" on="2015-04-13" change="Add base-output-uri option"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <modified by="Michael Kay" on="2018-06-14" change="Formatted for readability"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
                    let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                                    <xsl:template match='/'>
                                       <xsl:for-each select='//section'>
                                           <xsl:result-document href='section{position()}.html'> 
                                              <!-- instructions content here -->
                                            </xsl:result-document> 
                                       </xsl:for-each>
                                    </xsl:template> 
                                 </xsl:stylesheet>"
                    , $xml := "<doc>
                                   <section>sect1</section>
                                   <section>sect2</section>
                                   <section>sect3</section>
                               </doc>"
                    return
                       fn:transform(map {"stylesheet-text": $xsl, 
                                         "source-node": parse-xml($xml),
                                         "base-output-uri":"http://www.w3.org/fots/fn/transform/output-doc.xml"}) 
                            => map:remove("http://www.w3.org/fots/fn/transform/output-doc.xml")]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 3</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(string-join(map:keys($result)),"section2")</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-13a">
        <description>Transform producing multiple result documents (with content)</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
                    let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                                    <xsl:template match='/'> 
                                       <xsl:for-each select='//section'>
                                         <xsl:result-document href='section{position()}.html'> <!-- instructions content here -->
                                           <html>
                                             <head>
                                                 <title>Section <xsl:value-of select='position()'/></title>
                                             </head>
                                             <body>
                                                 <h1>Header for section <xsl:value-of select='position()'/></h1>
                                                 <p>The content of <xsl:value-of select='.'/>.</p>
                                                 <xsl:if test='position() ne last()'>
                                                     <p><a href='section{position()+1}.html'>Next section</a></p>
                                                 </xsl:if>
                                                 <xsl:if test='position() eq last()'>
                                                     <p><a href='section1.html'>First section</a></p>
                                                 </xsl:if>
                                             </body>
                                         </html>
                                       </xsl:result-document>
                                    </xsl:for-each>
                                  </xsl:template>
                                </xsl:stylesheet>"
                    , $xml := "<doc>
                                  <section>sect1</section>
                                  <section>sect2</section>
                                  <section>sect3</section>
                               </doc>"
                    return
                      fn:transform(map {"stylesheet-text": $xsl, 
                                        "source-node": parse-xml($xml),
                                        "base-output-uri":"http://www.w3.org/fots/fn/transform/output-doc.xml"})
                         => map:remove("http://www.w3.org/fots/fn/transform/output-doc.xml")]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 3</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(string-join(map:keys($result)),"www.w3.org/fots/fn/transform/section2")</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-14">
        <description>Transform producing multiple result documents, with base-output-uri option</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="multiple-result-docs"/>
        <test>fn:transform(map {"stylesheet-node":$multipledocs, "source-node":$sections, "base-output-uri": "http://www.w3.org/fots/fn/transform/output-doc.xml"})
            => map:remove("http://www.w3.org/fots/fn/transform/output-doc.xml")
            => map:keys()</test>
        <result>
            <assert-permutation>("http://www.w3.org/fots/fn/transform/section1.html","http://www.w3.org/fots/fn/transform/section2.html","http://www.w3.org/fots/fn/transform/section3.html")</assert-permutation>
        </result>
    </test-case>

    <test-case name="fn-transform-15">
        <description>Transform using option stylesheet-params with multiple params</description>
        <created by="Debbie Lockett" on="2015-03-10"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="variable-uri"/>
        <test>
            <![CDATA[
                    let $in := parse-xml("<dummy/>")/*,
                        $style := parse-xml("<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                        <xsl:param name='v'/>
                        <xsl:param name='w'/>
                        <xsl:param name='x'/>
                        <xsl:param name='y'/>
                        <xsl:template match='dummy'>
                        <out>
                            <v><xsl:value-of select='$v'/></v>
                            <w><xsl:value-of select='$w'/></w>
                            <x><xsl:value-of select='$x'/></x>
                            <y><xsl:value-of select='$y'/></y>
                            </out>
                        </xsl:template>
                    </xsl:stylesheet>")
                    return (transform(map{"source-node":$in, "stylesheet-node":$style, "stylesheet-params": map { QName("","v"): "2", QName("","w"): "3", QName("","y"): "5", QName("","x"): "4" } } ) )("output")
            ]]>
        </test>
        <result>
            <all-of>
                <assert>$result instance of node()</assert>
                <assert-xml><![CDATA[<out><v>2</v><w>3</w><x>4</x><y>5</y></out>]]></assert-xml>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-16">
        <description>Transform using option base-output-uri</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "document", "base-output-uri" : $base-uri})($base-uri)</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-17">
        <description>Transform using option base-output-uri</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "document", "base-output-uri" : $base-uri})</test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>map:contains($result, "http://www.w3.org/fots/fn/transform/output-doc.xml")</assert>
                <assert>$result("http://www.w3.org/fots/fn/transform/output-doc.xml") instance of node()</assert>
                <assert>count($result("http://www.w3.org/fots/fn/transform/output-doc.xml")//employee) > 0</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-18">
        <description>Transform using options stylesheet-text and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet version='2.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                    <xsl:template name='main'>
                    <x><xsl:value-of select='static-base-uri()'/></x>
                    </xsl:template>
                    </xsl:stylesheet>"
            return
            fn:transform(map {"stylesheet-text" : $xsl, "initial-template" : QName('','main'), "stylesheet-base-uri": "http://www.example.com"})?output
            ]]></test>
        <result>
            <assert>$result/x = 'http://www.example.com'</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-19">
        <description>Transform using options stylesheet-node and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="Tim Mills" on="2016-10-25" change="Bug 29946"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            declare base-uri "http://www.example.com/base";
            let $xsl  :="<xsl:stylesheet version='2.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                    <xsl:template name='main'>
                    <x><xsl:value-of select='static-base-uri()'/></x>
                    </xsl:template>
                    </xsl:stylesheet>"
            return
            fn:transform(map {"stylesheet-node" : parse-xml($xsl), "initial-template" : QName('','main'), "stylesheet-base-uri": "http://www.example.com"})?output
            ]]></test>
        <result>
	    <any-of>
            <assert>$result/x = 'http://www.example.com'</assert>
            <assert>$result/x = 'http://www.example.com/base'</assert>
	    </any-of>
        </result>
    </test-case>

    <test-case name="fn-transform-20">
        <description>Transform using options stylesheet-location and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Tim Mills" on="2016-10-25" change="Bug 29946"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment>
            <source role="$staticbaseuri" file="transform/staticbaseuri.xsl"  uri="http://www.w3.org/fots/fn/transform/staticbaseuri.xsl"/>
        </environment>
        <test>fn:transform(map {"stylesheet-location" : "http://www.w3.org/fots/fn/transform/staticbaseuri.xsl", 
                                "initial-template" : QName('','main'), 
                                "stylesheet-base-uri": "http://www.example.com"})("output")</test>
        <result>
	    <any-of>
            <assert>$result/x = 'http://www.example.com'</assert>
            <assert>$result/x = 'http://www.w3.org/fots/fn/transform/staticbaseuri.xsl'</assert>
	    </any-of>
        </result>
    </test-case>

    <test-case name="fn-transform-21">
        <description>Transform using static base URI default from option stylesheet-location</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment>
            <source role="$staticbaseuri" file="transform/staticbaseuri.xsl"  uri="http://www.w3.org/fots/fn/transform/staticbaseuri.xsl"/>
        </environment>
        <test>fn:transform(map {"stylesheet-location" : "http://www.w3.org/fots/fn/transform/staticbaseuri.xsl", "initial-template" : QName('','main')})("output")</test>
        <result>
            <assert>$result/x = 'http://www.w3.org/fots/fn/transform/staticbaseuri.xsl'</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-22">
        <description>Transform using xsl:include with relative href, using options stylesheet-text and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet version='2.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                    <xsl:include href='transform/staticbaseuri.xsl'/>
                    </xsl:stylesheet>"
            return
            fn:transform(map {"stylesheet-text" : $xsl, "initial-template" : QName('','main'), "stylesheet-base-uri": string(static-base-uri())})?output
            ]]></test>
        <result>
            <assert>contains($result/x,'fn/transform/staticbaseuri.xsl')</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-23">
        <description>Transform using xsl:include with relative href, using options stylesheet-node and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-local"/>
        <test>fn:transform(map {"stylesheet-node" : $include, "source-node" : $works, "stylesheet-base-uri": string(base-uri($include))})("output")</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-24">
        <description>Transform using xsl:include with relative href, with static base URI default from option stylesheet-node</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-local"/>
        <test>fn:transform(map {"stylesheet-node" : $include, "source-node" : $works})("output")</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-25">
        <description>Transform using stylesheet-location (with a relative URI)</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-local"/>
        <test>fn:transform(map {"stylesheet-location" : "transform/render.xsl", "source-node" : $works})("output")</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-26">
        <description>Transform using cache option true</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="Michael Kay" on="2015-12-14" change="result now indicates whether caching took place"/>
        <modified by="O'Neil Delpratt" on="2016-10-24" change="Bug fix relating to issue #29942" />
        <modified by="Tim Mills" on="2016-10-25" change="Bug 29942"/>
        <modified by="Michael Kay" on="2017-04-07" change="Now runs in XPath as suggested by bug 29997"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet version='3.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                <xsl:variable name='dateTime' static='yes' select='current-dateTime()'/>
                <xsl:template match='/'>
                    <x><xsl:value-of select='$dateTime'/></x>
                </xsl:template>
            </xsl:stylesheet>"
            return let $output1 := fn:transform(map {"stylesheet-text" : $xsl, "source-node" : parse-xml("<doc1/>"), "cache":true()})?output//x/string()
            return let $output2 := fn:transform(map {"stylesheet-text" : $xsl, "source-node" : parse-xml("<doc2/>")})?output//x/string()
            return trace($output1,'output1') eq trace($output2,'output2')
            ]]></test>
        <result>
	  <any-of>
            <assert-true/>  <!-- caching seems to have taken place -->
            <assert-false/>  <!-- caching seems not to have taken place -->
	  </any-of>
        </result>
    </test-case>

    <test-case name="fn-transform-27">
        <description>Transform using cache option false</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="O'Neil Delpratt" on="2016-10-24" change="Bug fix relating to issue #29942" />
        <modified by="O'Neil Delpratt" on="2016-11-17" change="Bug fix relating to issue #29965" />
        <modified by="Michael Kay" on="2017-04-07" change="Now runs in XPath as suggested by bug 29997"/>
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet version='3.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                <xsl:variable name='dateTime' static='yes' select='current-dateTime()'/>
                <xsl:template match='/'>
                    <x><xsl:value-of select='$dateTime'/></x>
                </xsl:template>
            </xsl:stylesheet>"
            return let $output1 := fn:transform(map {"stylesheet-text" : $xsl, "source-node" : parse-xml("<doc1/>"), "cache":false()})?output//x/string()
            return let $output2 := fn:transform(map {"stylesheet-text" : $xsl, "source-node" : parse-xml("<doc2/>"), "cache":false()})?output//x/string()
            return trace($output1,'output1') eq trace($output2,'output2')
            ]]></test>
        <result>
            <assert-false/>
        </result>
    </test-case>

    <test-case name="fn-transform-28">
        <description>Transform using serialized delivery-format option, and serialization-params (no indent)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-10-18" change="Bug 29440/29443: serialization params changed"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized",
            "serialization-params" : map { "indent": false() } })</test>
        <result>
            <all-of>
                <assert>$result("output") instance of xs:string</assert>
                <assert><![CDATA[contains($result("output"), "<works>")]]></assert>
                <assert><![CDATA[contains($result("output"), "</works>")]]></assert>
                <assert><![CDATA[contains($result("output"), "<body><works>")]]></assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-29">
        <description>Transform using serialized delivery-format option, and serialization-params (yes indent)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-10-19" change="Bug 29440/29443: serialization params changed"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized",
            "serialization-params" : map { "indent": true() } })</test>
        <result>
            <all-of>
                <assert>$result("output") instance of xs:string</assert>
                <assert><![CDATA[contains($result("output"), "<works>")]]></assert>
                <assert><![CDATA[contains($result("output"), "</works>")]]></assert>
                <assert><![CDATA[not(contains($result("output"), "<body><works>"))]]></assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-30">
        <description>Transforms using serialized delivery-format option, and serialization-params (yes and no indent)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-10-19" change="Bug 29440/29443: serialization params changed"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>let $out1 := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized",
            "serialization-params" : map { "indent":true() } })("output"),
            $out2 := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized",
            "serialization-params" : map { "indent":false() } })("output")
            return $out1 eq $out2
        </test>
        <result>
            <assert-false/>
        </result>
    </test-case>

    <test-case name="fn-transform-31">
        <description>Transform using option serialization-params, to output result as html (with delivery-format serialized)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-10-19" change="Bug 29440/29443: serialization params changed"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test>
            <![CDATA[
                    let $in := xs:string("<books>
    <book>
        <title>XSLT Programmer?s Reference</title>
        <author>Michael H. Kay</author>
    </book>
    <book>
        <title>XSLT</title>
        <author>Doug Tidwell</author>
        <author>Simon St. Laurent</author>
        <author>Robert Romano</author>
    </book>
</books>"),
    $style := xs:string('<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template match="/">
        <html>
            <body>
                <div>
                    <xsl:for-each select="books/book">
                        <b><xsl:value-of select="title"/></b>: <xsl:value-of select="author"
                        /><br/>
                    </xsl:for-each>
                </div>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>')
return transform(map{"source-node":fn:parse-xml($in), "stylesheet-text":$style, "delivery-format":"serialized",
"serialization-params": map{"method": "html" }} )("output")]]>
        </test>
        <result>
            <assert><![CDATA[contains($result, '<br>')]]></assert>
        </result>
    </test-case>

    <test-case name="fn-transform-32">
        <description>Transform using option serialization-params, to output result as xml (with delivery-format serialized)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-10-19" change="Bug 29440/29443: serialization params changed"/>
        <modified by="Michael Kay" on="2017-04-07" change="Now runs in XPath as suggested by bug 29997"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test>
            <![CDATA[
                    let $in := xs:string("<books>
    <book>
        <title>XSLT Programmer?s Reference</title>
        <author>Michael H. Kay</author>
    </book>
    <book>
        <title>XSLT</title>
        <author>Doug Tidwell</author>
        <author>Simon St. Laurent</author>
        <author>Robert Romano</author>
    </book>
</books>")
return let $style := xs:string('<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template match="/">
        <html>
            <body>
                <div>
                    <xsl:for-each select="books/book">
                        <b><xsl:value-of select="title"/></b>: <xsl:value-of select="author"
                        /><br/>
                    </xsl:for-each>
                </div>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>')
return transform(map{"source-node":fn:parse-xml($in), "stylesheet-text":$style, "delivery-format":"serialized",
"serialization-params": map{"method": "xml"} } )("output")]]>
        </test>
        <result>
            <assert><![CDATA[contains($result, '<br/>')]]></assert>
        </result>
    </test-case>

    <test-case name="fn-transform-33">
        <description>Transform producing multiple result documents, using serialized delivery-format</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <modified by="Debbie Lockett" on="2015-04-13" change="added base-output-uri option"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
                    let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                                                <xsl:template match='/'> <xsl:for-each select='//section'>
                                                <xsl:result-document href='section{position()}.html'> <!-- instructions content here -->
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>"
                    , $xml := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   <section>sect3</section>
                                                   </doc>"
                    return
            fn:transform(map {"stylesheet-text": $xsl, "source-node": parse-xml($xml),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-33.xml", static-base-uri()),
            "delivery-format":"serialized"})
            => map:remove(resolve-uri("transform/sandbox/fn-transform-33.xml", static-base-uri()))]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 3</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(string-join(map:keys($result)),"section2")</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-34">
        <description>Transform using option base-output-uri, and document delivery-format</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <modified by="Michael Kay" on="2016-11-30" change="Bug 29951 - delivery=saved has been dropped"/>
        <modified by="Michael Kay" on="2017-04-05" change="Change assertion: result is a doc so no parse needed"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-local"/>
        <test>fn:transform(map {"stylesheet-node" : $render, "source-node" : $works,
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-34.xml", static-base-uri()),
            "delivery-format" : "document"})?*</test>
        <result>
            <all-of>
                <assert>$result instance of document-node()</assert>
                <assert>count($result//employee) > 3</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-35">
        <description>Transform using option base-output-uri, and serialized delivery-format</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <modified by="Michael Kay" on="2016-11-30" change="Bug 29951 - delivery=saved has been dropped"/>      
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-35.xml", static-base-uri()),
            "delivery-format" : "serialized"})</test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 1</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(map:keys($result), 'fn-transform-35.xml')</assert>
                <assert>$result?* instance of xs:string</assert>
                <!--<assert>contains($result?*, 'fn-transform-35.xml')</assert>-->
                <assert>count(parse-xml($result?*)//employee) > 3</assert>
                <!--<assert>count(doc(map:keys($result))//employee) > 3</assert>-->
                <assert>some $key in map:keys($result) satisfies ends-with($key,
                    'transform/sandbox/fn-transform-35.xml')</assert>
                <!--<assert>some $key in map:keys($result) satisfies (
                    ends-with($key,
                    'transform/sandbox/fn-transform-35.xml') and $result?($key) = $key)</assert>-->
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-36">
        <description>Transform using serialized delivery-format option, and serialization-params (yes
            indent)</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <modified by="Debbie Lockett" on="2015-04-02" change="Assertions added to check use of serialization-param"/>
        <modified by="Michael Kay" on="2016-10-19" change="Bug 29440/29443: serialization params changed"/>
        <modified by="Michael Kay" on="2016-11-30" change="Bug 29951 - delivery=saved has been dropped"/>
        <modified by="Michael Kay" on="2017-04-05" change="Correct expected results"/>
        <modified by="O'Neil Delpratt" on="2017-07-04" change="Bug 30134 - Changed affected assert elements using doc function"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-36.xml", static-base-uri()),
            "delivery-format" : "serialized", "serialization-params" : map { "indent": true() }
            })</test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 1</assert>
                <assert>ends-with(map:keys($result), 'transform/sandbox/fn-transform-36.xml')</assert>
                <assert>$result?* instance of xs:string</assert>
                <assert>count(parse-xml($result?*)//employee) > 3</assert>
                <!--<assert><![CDATA[contains(serialize(doc(map:keys($result))), "<works>")]]></assert>-->
                <assert><![CDATA[contains($result?*, "<works>")]]></assert>
                <!--<assert><![CDATA[contains(serialize(doc(map:keys($result))), "</works>")]]></assert>-->
                <assert><![CDATA[contains($result?*, "</works>")]]></assert>
                <!--<assert><![CDATA[not(contains(serialize(doc(map:keys($result))), "<body><works>"))]]></assert>-->
                <assert><![CDATA[not(contains($result?*, "<body><works>"))]]></assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-36a">
        <description>Transform using serialized delivery-format option, and serialization-params (no
            indent)</description>
        <created by="Debbie Lockett" on="2015-04-02"/>
        <modified by="Michael Kay" on="2016-10-19" change="Bug 29440/29443: serialization params changed"/>
        <modified by="Michael Kay" on="2016-11-30" change="Bug 29951 - delivery=saved has been dropped"/>
        <modified by="O'Neil Delpratt" on="2017-07-04" change="Bug 30134 - Changed affected assert elements using doc function"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-36a.xml", static-base-uri()),
            "delivery-format" : "serialized", "serialization-params" : map { "indent": false() }
            })</test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 1</assert>
                <assert>ends-with(map:keys($result), 'transform/sandbox/fn-transform-36a.xml')</assert>
                <assert>$result?* instance of xs:string</assert>
                <assert>count(parse-xml($result?*)//employee) > 3</assert>
                <!--<assert><![CDATA[contains(serialize(doc(map:keys($result))), "<works>")]]></assert>-->
                <assert><![CDATA[contains($result?*, "<works>")]]></assert>
                <!--<assert><![CDATA[contains(serialize(doc(map:keys($result))), "</works>")]]></assert>-->
                <assert><![CDATA[contains($result?*, "</works>")]]></assert>
                <!--<assert><![CDATA[not(contains(serialize(doc(map:keys($result))), "<body><works>"))]]></assert>-->
                <assert><![CDATA[contains($result?*, "<body><works>")]]></assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-37">
        <description>Transform producing multiple result documents, using serialized delivery-format and
            base-output-uri options</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <modified by="Michael Kay" on="2016-11-30" change="Bug 29951 - delivery=saved has been dropped"/>
        <modified by="O'Neil Delpratt" on="2017-07-04" change="Bug 30134 - Changed affected assert elements using doc function"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
                    let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                                                <xsl:template match='/'> <xsl:for-each select='//section'>
                                                <xsl:result-document href='section{position()}-page.html'> <!-- instructions content here -->
                                                    <html>
                                                        <body>
                                                            <h1>Section <xsl:value-of select='position()'/></h1>
                                                            <p>Some text here.</p>
                                                        </body>
                                                    </html>
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>"
                    , $xml := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   <section>sect3</section>
                                                   </doc>"
                    return
            fn:transform(map {"stylesheet-text": $xsl, "source-node": parse-xml($xml),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-37/output.html", static-base-uri()),
            "delivery-format":"serialized"})
            => map:remove(resolve-uri("transform/sandbox/fn-transform-37/output.html", static-base-uri()))]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 3</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(string-join(map:keys($result)),"section1")</assert>
                <assert>some $key in map:keys($result) satisfies ends-with($key,
                    'transform/sandbox/fn-transform-37/section3-page.html')</assert>
                <assert><![CDATA[some $key in map:keys($result) satisfies parse-xml(map:get($result, $key))//h1 = 'Section 2']]></assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-38">
        <description>Transform producing multiple result documents, using serialized delivery-format and
            base-output-uri options</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, use function-style map lookup"/>
        <modified by="O'Neil Delpratt" on="2017-07-04" change="Bug 30134 - commented out affected assert elements using doc function"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="multiple-result-docs"/>
        <test>let $res := fn:transform(map {"stylesheet-node":$multipledocs, "source-node":$sections,
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-38/output.html",
            static-base-uri()), "delivery-format":"serialized"}) return map:keys($res)</test>
        <result>
            <all-of>
                <assert>count($result) = (3, 4)</assert>
                <assert>contains(string-join($result), 'section1.html')</assert>
                <assert>some $key in $result satisfies ends-with($key,
                    'transform/sandbox/fn-transform-38/section3.html')</assert>
                <!--<assert><![CDATA[some $key in $result satisfies doc($key)//h1 = 'Header for section 2']]></assert>-->
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-39">
        <description>Transform producing multiple result documents, using serialized delivery-format
            option, but no base-output-uri (xsl:result-document/@href is absolute)</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="Added XP31+ dependency, use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-11-30" change="Bug 29951 - delivery=saved has been dropped"/>
        <modified by="O'Neil Delpratt" on="2017-07-04" change="Bug 30134 - Changed affected assert elements using doc function"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment name="multiple-result-docs2">
            <source role="$multipledocs2" file="transform/multipledocs2.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>let $res := fn:transform(map {"stylesheet-node":$multipledocs2, "source-node":$sections,
            "delivery-format":"serialized"}) return map:keys($res)</test>
        <result>
            <all-of>
                <assert>count($result) = (3, 4)</assert>
                <assert>contains(string-join($result), 'section1.html')</assert>
                <assert>some $key in $result satisfies ends-with($key,
                    'transform/sandbox/fn-transform-39/section3.html')</assert>
                <!--<assert><![CDATA[some $key in $result satisfies doc($key)//h1 = 'Header for section 2']]></assert>-->
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-40">
        <description>Transform producing one result document (as secondary result doc), using serialized
            delivery-format and base-output-uri options</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <modified by="Michael Kay" on="2016-11-30" change="Bug 29951 - delivery=saved has been dropped"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment name="onedoc">
            <source role="$onedoc" file="transform/onedoc.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node" : $onedoc, "source-node" : $sections,
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-40/output.html",
            static-base-uri()), "delivery-format" : "serialized"})</test>
        <result>
            <all-of>
                <assert>map:size($result) = 1 to 2</assert>
                <!--<assert>ends-with($result?*, 'transform/sandbox/fn-transform-40/section1.html')</assert>
                <assert>ends-with(map:keys($result), 'transform/sandbox/fn-transform-40/section1.html')</assert>
                <assert><![CDATA[doc('transform/sandbox/fn-transform-40/section1.html')//h1 = 'Header for section 1']]></assert>-->
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-41">
        <description>Transform using options stylesheet-node and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-04-01"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Tim Mills" on="2016-10-25" change="Bug 29946"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment>
            <source role="$staticbaseuri" file="transform/staticbaseuri.xsl"  uri="http://www.w3.org/fots/fn/transform/staticbaseuri.xsl"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node" : $staticbaseuri, "initial-template" : QName('','main'), "stylesheet-base-uri": "http://www.example.com"})("output")</test>
        <result>
	    <any-of>
            <assert>$result/x = 'http://www.example.com'</assert>
            <assert>$result/x = 'http://www.w3.org/fots/fn/transform/staticbaseuri.xsl'</assert>
	    </any-of>
        </result>
    </test-case>

    <test-case name="fn-transform-42">
        <description>Transform using static base URI default from option stylesheet-node</description>
        <created by="Debbie Lockett" on="2015-04-01"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment>
            <source role="$staticbaseuri" file="transform/staticbaseuri.xsl"  uri="http://www.w3.org/fots/fn/transform/staticbaseuri.xsl"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node" : $staticbaseuri, "initial-template" : QName('','main')})("output")</test>
        <result>
            <assert>$result/x = 'http://www.w3.org/fots/fn/transform/staticbaseuri.xsl'</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-43">
        <description>Transform producing multiple result documents, using serialized delivery-format and
            base-output-uri options</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="multiple-result-docs"/>
        <test>fn:transform(map {"stylesheet-node":$multipledocs, "source-node":$sections,
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-43/output.html",
            static-base-uri()), "delivery-format":"serialized"})</test>
        <result>
            <all-of>
                <assert>map:size($result) = 3 to 4</assert>
                <assert>contains(string-join(map:keys($result)), 'section1.html')</assert>
                <assert>some $key in map:keys($result) satisfies ends-with($key,
                    'transform/sandbox/fn-transform-43/section3.html')</assert>
                <assert><![CDATA[some $key in map:keys($result) satisfies parse-xml($result?($key))//h1 = 'Header for section 2']]></assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-44">
        <description>Transform producing multiple result documents, using serialized delivery-format and
            base-output-uri options</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
                    let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                                                <xsl:template match='/'> <xsl:for-each select='//section'>
                                                <xsl:result-document href='section{position()}.xml'> <!-- instructions content here -->
                                                <out>
                                                <xsl:value-of select='position()'/>
                                                </out>
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>"
                    , $xml := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   <section>sect3</section>
                                                   </doc>"
                    return
            fn:transform(map {"stylesheet-text": $xsl, "source-node": parse-xml($xml),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-44/output.xml", static-base-uri()),
            "delivery-format":"serialized"})
            => map:remove(resolve-uri("transform/sandbox/fn-transform-44/output.xml", static-base-uri()))]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 3</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(string-join(map:keys($result)),"section2")</assert>
                <assert>some $key in map:keys($result) satisfies ends-with($key,
                    'transform/sandbox/fn-transform-44/section3.xml')</assert>
                <assert><![CDATA[some $key in map:keys($result) satisfies parse-xml($result?($key))//out = '2']]></assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-45">
        <description>Transform using option base-output-uri, and serialized delivery-format</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-10-07" change="see bug 29922"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-45.xml", static-base-uri()),
            "delivery-format" : "serialized"})</test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 1</assert>
                <assert>ends-with(map:keys($result)[1], 'transform/sandbox/fn-transform-45.xml')</assert>
                <assert>$result(map:keys($result)[1]) instance of xs:string</assert>
                <assert>contains($result(map:keys($result)[1]), "&lt;works>")</assert>
                <assert>count(parse-xml($result(map:keys($result)[1]))//employee) > 3</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-46">
        <description>Transform producing multiple result documents, using serialized delivery-format
            option, but no base-output-uri (xsl:result-document/@href is absolute)</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment name="multiple-result-docs2">
            <source role="$multipledocs2" file="transform/multipledocs2.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node":$multipledocs2, "source-node":$sections,
            "delivery-format":"serialized"})</test>
        <result>
            <all-of>
                <assert>count(map:keys($result)) = 3 to 4</assert>
                <assert>contains(string-join(map:keys($result)), 'section1.html')</assert>
                <assert>some $key in map:keys($result) satisfies ends-with($key, 'transform/sandbox/fn-transform-39/section3.html')</assert>
                <assert>some $key in map:keys($result)[contains(., 'section')] satisfies parse-xml($result($key))//h1 = 'Header for section 2'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-47">
        <description>Transform producing multiple result documents, using document delivery-format
            option, but no base-output-uri (xsl:result-document/@href is absolute)</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment name="multiple-result-docs2">
            <source role="$multipledocs2" file="transform/multipledocs2.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node":$multipledocs2, "source-node":$sections,
            "delivery-format":"document"})</test>
        <result>
            <all-of>
                <assert>count(map:keys($result)) = 3 to 4</assert>
                <assert>contains(string-join(map:keys($result)), 'section1.html')</assert>
                <assert>some $key in map:keys($result) satisfies ends-with($key,
                    'transform/sandbox/fn-transform-39/section3.html')</assert>
                <assert>some $key in map:keys($result) satisfies $result($key)//h1 = 'Header for section 2'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-48">
        <description>Transform with additional unrecognised option which is ignored</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <modified by="Michael Kay" on="2015-11-26" change="avoid HOF dependency in assertions"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template name='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-template": fn:QName('','main'),
            "another-option" : "dummy"})
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result?output instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>


    <test-case name="fn-transform-50">
        <description>Transform using XSLT 3.0 option static-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:param name='static-param' static='yes' select='&quot;success&quot;'/>
                <xsl:template match='/'>
                    <out><xsl:value-of select='$static-param'/></out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-node":parse-xml($xsl), "source-node":parse-xml("<doc>this</doc>"),
            "static-params":map{QName('','static-param'):"Hello World"}
            })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'Hello World'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-51">
        <description>Transform using XSLT 3.0 option static-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:param name='static-param' static='yes' select='&quot;success&quot;'/>
                <xsl:param name='alt-param' static='yes' select='upper-case($static-param)'/>
                <xsl:template match='/'>
                    <out><xsl:value-of select='$static-param'/><xsl:value-of select='$alt-param'/></out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-node":parse-xml($xsl), "source-node":parse-xml("<doc>this</doc>"),
            "static-params":map{QName('','static-param'):"Hello"}
            })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'HelloHELLO'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-52">
        <description>Transform using XSLT 3.0 option static-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:param name='static-param' static='yes' select='&quot;success&quot;'/>
                <xsl:param name='alt-param' static='yes' select='upper-case($static-param)'/>
                <xsl:template match='/'>
                    <out><xsl:value-of select='$static-param'/><xsl:value-of select='$alt-param'/></out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-node":parse-xml($xsl), "source-node":parse-xml("<doc>this</doc>"),
            "static-params":map{QName('','static-param'):"Hello", QName('','alt-param'):"World"}
            })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'HelloWorld'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-53">
        <description>Transform using XSLT 3.0 option template-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:template name='main'>
                <xsl:param name='template-param' select='&quot;old&quot;'/>
                    <out>
                        <xsl:value-of select='$template-param' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-template": fn:QName('','main'),
            "template-params": map{QName('','template-param'):"new"}
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out/text() = 'new'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-54">
        <description>Transform using XSLT 3.0 option template-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:template name='main'>
                <xsl:param name='param1' select='&quot;old1&quot;'/>
                <xsl:param name='param2' select='&quot;old2&quot;'/>
                <xsl:param name='param3' select='&quot;old3&quot;'/>
                    <out>
                        <xsl:value-of select='$param1' />
                        <xsl:value-of select='$param2' />
                        <xsl:value-of select='$param3' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-template": fn:QName('','main'),
            "template-params": map{QName('','param1'):"new1", QName('','param2'):"new2", QName('','param4'):"new4"}
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out/text() = 'new1new2old3'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-55">
        <description>Transform using XSLT 3.0 option template-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:template name='main'>
                <xsl:param name='param1' select='&quot;old1&quot;'/>
                <xsl:param name='param2' required='yes'/>
                <xsl:param name='param3' select='&quot;old3&quot;'/>
                    <out>
                        <xsl:value-of select='$param1' />
                        <xsl:value-of select='$param2' />
                        <xsl:value-of select='$param3' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-template": fn:QName('','main'),
            "template-params": map{QName('','param1'):"new1", QName('','param2'):"new2"}
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out/text() = 'new1new2old3'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-56">
        <description>Transform using XSLT 3.0 option template-params (note $param1 is tunnel param so not set)</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:template name='main'>
                <xsl:param name='param1' select='&quot;old1&quot;' tunnel='yes'/>
                <xsl:param name='param2' select='&quot;old2&quot;'/>
                <xsl:param name='param3' select='&quot;old3&quot;'/>
                    <out>
                        <xsl:value-of select='$param1' />
                        <xsl:value-of select='$param2' />
                        <xsl:value-of select='$param3' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-template": fn:QName('','main'),
            "template-params": map{QName('','param1'):"new1", QName('','param2'):"new2", QName('','param4'):"new4"}
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out/text() = 'old1new2old3'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-57">
        <description>Transform using XSLT 3.0 option tunnel-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:template name='main'>
                <xsl:param name='param1' select='&quot;old1&quot;' tunnel='yes'/>
                <xsl:param name='param2' select='&quot;old2&quot;'/>
                <xsl:param name='param3' select='&quot;old3&quot;'/>
                    <out>
                        <xsl:value-of select='$param1' />
                        <xsl:value-of select='$param2' />
                        <xsl:value-of select='$param3' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-template": fn:QName('','main'),
            "tunnel-params": map{QName('','param1'):"tunnel1", QName('','param2'):"tunnel2"}
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out/text() = 'tunnel1old2old3'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-58">
        <description>Transform using XSLT 3.0 options template-params and tunnel-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:template name='main'>
                <xsl:param name='param1' select='&quot;old1&quot;' tunnel='yes'/>
                <xsl:param name='param2' select='&quot;old2&quot;'/>
                <xsl:param name='param3' select='&quot;old3&quot;'/>
                    <out>
                        <xsl:value-of select='$param1' />
                        <xsl:value-of select='$param2' />
                        <xsl:value-of select='$param3' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-template": fn:QName('','main'),
            "template-params": map{QName('','param1'):"new1", QName('','param2'):"new2", QName('','param4'):"new4"},
            "tunnel-params": map{QName('','param1'):"tunnel1", QName('','param2'):"tunnel2"}
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out/text() = 'tunnel1new2old3'</assert>
            </all-of>
        </result>
    </test-case>



    <test-case name="fn-transform-60">
        <description>Transform using XSLT 3.0 options initial-function and function-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <modified by="Michael Kay" on="2017-04-05" change="externally-invoked function must be public"/>
        <modified by="Michael Kay" on="2018-06-14" change="default delivery format is 'document', so the result should have a document node"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='3.0'>
                <xsl:function name='my:user-function' visibility='public'>
                    <xsl:param name='param1'/>
                    <xsl:param name='param2'/>
                    <this>
                    <xsl:value-of select='$param1'/><xsl:value-of select='$param2'/>
                    </this>
                </xsl:function>
                <xsl:template name='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-function": fn:QName('http://www.w3.org/fots/fn/transform/myfunctions','user-function'),
            "function-params": ["new1","new2"]
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result("output") instance of document-node()</assert>
                <assert>$result?output/this = 'new1new2'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-61">
        <description>Transform using XSLT 3.0 options initial-function and function-params
        for version 2.0 stylesheet (needs an XSLT 3.0 processor)</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <modified by="Michael Kay" on="2017-04-05" change="externally-invoked function must be public"/>
        <modified by="Michael Kay" on="2018-06-14" change="default delivery format is 'document', so the result should have a document node"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='2.0'>
                <xsl:function name='my:user-function' visibility='public'>
                    <xsl:param name='param1'/>
                    <xsl:param name='param2'/>
                    <this>
                    <xsl:value-of select='$param1'/><xsl:value-of select='$param2'/>
                    </this>
                </xsl:function>
                <xsl:template name='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{
                "stylesheet-text":$xsl, 
                "source-node":parse-xml("<doc>this</doc>"),
                "initial-function": fn:QName('http://www.w3.org/fots/fn/transform/myfunctions','user-function'),
                "function-params": ["new1","new2"],
                "xslt-version": 3.0
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result("output") instance of document-node()</assert>
                <assert>$result?output/this = 'new1new2'</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-62">
        <description>Transform with XSLT 3.0 delivery-format raw</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            version='2.0'>
                <xsl:template match='/' as='xs:integer'>
                    <xsl:sequence select='count(//*)'/>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<one><two/><three/><four/></one>"),
            "delivery-format":"raw"})
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of xs:integer</assert>
                <assert>$result?output = 4</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-63">
        <description>Transform using option initial-template with XSLT 3.0 delivery-format raw</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            version='2.0'>
                <xsl:template name='main' as='xs:integer'>
                    <xsl:sequence select='count(//*)'/>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<one><two/><three/><four/></one>"),
            "initial-template": QName('','main'),
            "delivery-format":"raw"})
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of xs:integer</assert>
                <assert>$result?output = 4</assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-64">
        <description>Transform using XSLT 3.0 options initial-function, function-params, and delivery-format raw</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <modified by="Michael Kay" on="2017-04-05" change="externally-invoked function must be public"/>
        <modified by="Michael Kay" on="2017-04-07" change="Now runs in XPath as suggested by bug 29997"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
              xmlns:xs='http://www.w3.org/2001/XMLSchema'
              xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='3.0'>
                <xsl:function name='my:user-function' as='xs:integer*' visibility='public'>
                    <xsl:param name='param1'/>
                    <xsl:param name='param2'/>
                    <xsl:sequence select='$param1 to $param2'/>
                </xsl:function>
            </xsl:stylesheet>"
            return transform(map{"stylesheet-text": $xsl,
                                 "initial-function": fn:QName('http://www.w3.org/fots/fn/transform/myfunctions','user-function'),
                                 "function-params": [1,5],
                                 "delivery-format": "raw"
            })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of xs:integer*</assert>
                <assert>$result?output = (1, 2, 3, 4, 5)</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-65">
        <description>Transform using serialization-param cdata-section-elements</description>
        <created by="Michael Kay" on="2016-10-19"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test><![CDATA[let $xsl :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='2.0'>
            <xsl:output cdata-section-elements='b my:b'/>
            <xsl:template name='main'>
              <my:a>
                <my:b>green</my:b>
                <my:c>blue</my:c>
                <b>red</b>
                <c>pink</c>
                <d>black</d>
              </my:a>
            </xsl:template>  
        </xsl:stylesheet>" return
            transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "serialization-params": map{'cdata-section-elements': (QName('http://www.w3.org/fots/fn/transform/myfunctions','c'), QName('', 'c'))}
            })]]></test>
        <result>
            <all-of>
                <assert>$result("output") instance of xs:string</assert>
                <assert><![CDATA[contains($result("output"), "[CDATA[green]]")]]></assert>
                <assert><![CDATA[contains($result("output"), "[CDATA[blue]]")]]></assert>
                <assert><![CDATA[contains($result("output"), "[CDATA[red]]")]]></assert>
                <assert><![CDATA[contains($result("output"), "[CDATA[pink]]")]]></assert>
                <assert><![CDATA[contains($result("output"), "<d>black</d>")]]></assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-66">
        <description>Transform using serialization-param suppress-indentation</description>
        <created by="Michael Kay" on="2016-10-19"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test><![CDATA[let $xsl :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='3.0'>
            <xsl:output indent='yes' suppress-indentation='b my:b'/>
            <xsl:template name='main'>
              <my:a>
                <my:b><t>green</t></my:b>
                <my:c><t>blue</t></my:c>
                <b><t>red</t></b>
                <c><t>pink</t></c>
                <d><t>black</t></d>
              </my:a>
            </xsl:template>  
        </xsl:stylesheet>" return
            transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "serialization-params": map{'suppress-indentation': (QName('http://www.w3.org/fots/fn/transform/myfunctions','c'), QName('', 'c'))}
            })]]></test>
        <result>
            <all-of>
                <assert>$result("output") instance of xs:string</assert>
                <assert><![CDATA[contains($result("output"), "><t>green</t><")]]></assert>
                <assert><![CDATA[contains($result("output"), "><t>blue</t><")]]></assert>
                <assert><![CDATA[contains($result("output"), "><t>red</t><")]]></assert>
                <assert><![CDATA[contains($result("output"), "><t>pink</t><")]]></assert>
                <assert><![CDATA[matches($result("output"), ">\s+<t>black</t>\s+<")]]></assert>
            </all-of>
        </result>
    </test-case>

    <test-case name="fn-transform-67">
        <description>Transform using merged character maps</description>
        <created by="Michael Kay" on="2016-10-19"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test><![CDATA[let $xsl :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='2.0'>
            <xsl:output use-character-maps='map-one'/>
            <xsl:character-map name='map-one'>
              <xsl:output-character character='-' string='(hyphen)'/>
              <xsl:output-character character='*' string='(asterisk)'/>
            </xsl:character-map>  
            <xsl:template name='main'>
              <out>a-b*c</out>
            </xsl:template>  
        </xsl:stylesheet>" return
            transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "serialization-params": map{'use-character-maps': map{'*':'(star)'}}
            })]]></test>
        <result>
            <all-of>
                <assert>$result("output") instance of xs:string</assert>
                <assert><![CDATA[contains($result("output"), ">a(hyphen)b(star)c</out>")]]></assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-68">
        <description>Transform with a request for a specific product</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            xmlns:saxon='http://saxon.sf.net/'
            xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='2.0'> 
            <xsl:template name='main'>
              <out><xsl:value-of select=""saxon:in-summer-time(xs:dateTime('2016-07-01T00:00:00'), 'Europe/London')""/></out>
            </xsl:template>  
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','vendor'):'Saxonica'}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert><![CDATA[contains($result("output"), ">true</out>")]]></assert>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-69">
        <description>Transform with a request for a specific product</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            xmlns:xalan='http://xml.apache.org'
            xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='2.0'>
            <xsl:variable name='v'>
              <a><b>42</b></a>
            </xsl:variable>  
            <xsl:template name='main'>
              <out product=""{system-property('xsl:vendor')}""><xsl:value-of select='xalan:node-set($v)/a/b'/></out>
            </xsl:template>  
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','product-name'):'Xalan'}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert><![CDATA[contains($result("output"), ">true</out>")]]></assert>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-70">
        <description>Transform with a request for a schema-aware transformer</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="schemaImport"/>
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            xmlns:chrono='http://chronology.com/' version='2.0'>
            <xsl:import-schema>
              <xs:schema targetNamespace='http://chronology.com/'>
                <xs:simpleType name='c4'>
                  <xs:restriction base='xs:string'>
                    <xs:pattern value='....'/>
                  </xs:restriction>  
                </xs:simpleType>
              </xs:schema>
            </xsl:import-schema>
            <xsl:template name='main'>
              <out><xsl:value-of select=""chrono:c4('abcd')""/></out>
            </xsl:template>  
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','is-schema-aware'):true()}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert><![CDATA[contains($result("output"), ">abcd</out>")]]></assert>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-71">
        <description>Transform with a request for a non-schema-aware transformer</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:xs='http://www.w3.org/2001/XMLSchema'
            xmlns:chrono='http://chronology.com/' version='2.0'>
            <xsl:import-schema>
              <xs:schema targetNamespace='http://chronology.com/'>
                <xs:simpleType name='c4'>
                  <xs:restriction base='xs:string'>
                    <xs:pattern value='....'/>
                  </xs:restriction>  
                </xs:simpleType>
              </xs:schema>
            </xsl:import-schema>
            <xsl:template name='main'>
              <out><xsl:value-of select=""chrono:c4('abcd')""/></out>
            </xsl:template>  
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','is-schema-aware'):false()}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <error code="XTSE1650"/>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-72">
        <description>Transform with a request for a transformer that supports backwards compatibility mode</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='2.0'>
            <xsl:template name='main'>
              <out><xsl:value-of select=""substring(current-date(), 1, 2) = '20'"" version='1.0'/></out>
            </xsl:template>  
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','supports-backwards-compatibility'):true()}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert><![CDATA[contains($result("output"), ">true</out>")]]></assert>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-73">
        <description>Transform with a request for a transformer that does not support backwards compatibility mode</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='2.0'>
            <xsl:template name='main'>
              <out><xsl:value-of select=""substring(current-date(), 1, 2) = '20'"" version='1.0'/></out>
            </xsl:template>  
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "initial-template": fn:QName('','main'),
            "delivery-format" : "serialized",
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','supports-backwards-compatibility'):false()}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <error code="XTDE0160"/>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-74">
        <description>Transform with a request for a transformer that supports the namespace axis</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='2.0'>
            <xsl:template match='/'>
              <out><xsl:value-of select='*/namespace::xsl'/></out>
            </xsl:template>  
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "source-node": parse-xml($xsl),
            "delivery-format" : "serialized",
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','supports-namespace-axis'):true()}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert><![CDATA[contains($result("output"), ">http://www.w3.org/1999/XSL/Transform</out>")]]></assert>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-75">
        <description>Transform with a request for a transformer that does not support the namespace axis</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='2.0'>
            <xsl:template match='/'>
              <out><xsl:value-of select='*/namespace::xsl'/></out>
            </xsl:template>  
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "source-node": parse-xml($xsl),
            "delivery-format" : "serialized",
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','supports-namespace-axis'):false()}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <error code="*"/>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-76">
        <description>Transform with a request for a transformer that supports streaming</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='3.0'>
            <xsl:mode streamable='yes'/>
            <xsl:template match='/'>
              <out><xsl:value-of select='x/y/z'/></out>
            </xsl:template> 
            <xsl:template name='main'>
              <out>ok</out>
            </xsl:template> 
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "delivery-format" : "serialized",
            "initial-template": fn:QName('','main'),
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','supports-streaming'):true()}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert><![CDATA[contains($result("output"), ">ok</out>")]]></assert>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-77">
        <description>Transform with a request for a transformer that supports streaming, but the stylesheet is not streamable</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='3.0'>
            <xsl:mode streamable='yes'/>
            <xsl:template match='/'>
              <out><xsl:value-of select='x/y + x/z'/></out>
            </xsl:template> 
            <xsl:template name='main'>
              <out>ok</out>
            </xsl:template> 
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "delivery-format" : "serialized",
            "initial-template": fn:QName('','main'),
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','supports-streaming'):true()}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <error code="XTSE3430"/>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-78">
        <description>Transform with a request for a transformer that supports XPath 3.1</description>
        <created by="Michael Kay" on="2016-11-01"/>
        <modified by="Michael Kay" on="2016-11-09" change="Make it valid XP31, bug 29993"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='3.0'> 
            <xsl:template name='main'>
              <out><xsl:value-of select='array{1,2,3}(2)'/></out>
            </xsl:template> 
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "delivery-format" : "serialized",
            "initial-template": fn:QName('','main'),
            "requested-properties" : map{fn:QName('http://www.w3.org/1999/XSL/Transform','xpath-version'):"3.1"}
            })]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert><![CDATA[contains($result("output"), ">2</out>")]]></assert>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-79">
        <description>Transform with a post-processing request, delivery-format document</description>
        <created by="Michael Kay" on="2016-11-30"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='1.0'> 
            <xsl:template match='/'>
              <out><xsl:copy-of select='.'/></out>
            </xsl:template> 
        </xsl:stylesheet>" return
        let $expected := parse-xml('<b>89</b>')/* return
        let $trans-result := transform(map{"stylesheet-text":$xsl,
            "delivery-format" : "document",
            "source-node": parse-xml('<a><b>89</b></a>'),
            "post-process" : function($uri, $doc) { $doc/out/a/b }
            }) return
        deep-equal(trace($trans-result("output"), 'actual'), $expected)]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert-true/>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-80">
        <description>Transform with a post-processing request, delivery-format serialized</description>
        <created by="Michael Kay" on="2016-11-30"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='1.0'> 
            <xsl:template match='/'>
              <out><xsl:copy-of select='.'/></out>
            </xsl:template> 
        </xsl:stylesheet>" return
        let $expected := parse-xml('<b>89</b>')/* return
        let $trans-result := transform(map{"stylesheet-text":$xsl,
            "delivery-format" : "serialized",
            "serialization-params" : map { "method":"xml", "omit-xml-declaration":true(), "indent":false() },
            "source-node": parse-xml('<a><b>89</b></a>'),
            "post-process" : function($uri, $out) { concat(substring($out, 1, 12), '...') }
            }) return
        deep-equal(trace($trans-result("output"), 'actual'), "<out><a><b>8...")]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert-true/>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-81">
        <description>Transform with a post-processing request, delivery-format serialized</description>
        <created by="Michael Kay" on="2016-11-30"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            version='1.0'> 
            <xsl:template match='/'>
              <xsl:sequence select='42'/>
            </xsl:template> 
        </xsl:stylesheet>" return
        let $expected := parse-xml('<b>89</b>')/* return
        let $trans-result := transform(map{"stylesheet-text":$xsl,
            "delivery-format" : "raw",
            "serialization-params" : map { "method":"xml", "omit-xml-declaration":true(), "indent":false() },
            "source-node": parse-xml('<a><b>89</b></a>'),
            "post-process" : function($uri, $out) { $out + 3 }
            }) return
        deep-equal(trace($trans-result("output"), 'actual'), 45)]]></test>
        <result>
            <any-of>
                <error code="FOXT0001"/>
                <assert-true/>
            </any-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-82a">
        <description>Value of global context item</description>
        <created by="Michael Kay" on="2017-09-07"/>
        <environment ref="variable-with-context"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
           let $in := parse-xml("<dummy/>")
           return transform(map{
              "source-node": $in, 
              "stylesheet-node": $stylesheet,
              "xslt-version": 3.0
           })?output
        ]]></test>
        <result>
            <all-of>
                <assert>$result/out/@root-is-doc = "true"</assert>
                <assert>$result/out/@this-is-doc = "true"</assert>
                <assert>$result/out = ""</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-82b">
        <description>Value of global context item</description>
        <created by="Michael Kay" on="2017-09-07"/>
        <environment ref="variable-with-context"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
           let $in := parse-xml("<dummy/>")
           return transform(map{
              "source-node": $in/*, 
              "stylesheet-node": $stylesheet,
              "xslt-version": 3.0
           })?output
        ]]></test>
        <result>
            <all-of>
                <assert>$result/out/@root-is-doc = "true"</assert>
                <assert>$result/out/@this-is-doc = "false"</assert>
                <assert>$result/out = ""</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-82c">
        <description>Value of global context item</description>
        <created by="Michael Kay" on="2017-09-07"/>
        <environment ref="variable-with-context"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
           let $in := parse-xml("<dummy/>")
           return transform(map{
              "source-node": $in,
              "global-context-item": $in/*,
              "stylesheet-node": $stylesheet,
              "xslt-version": 3.0
           })?output
        ]]></test>
        <result>
            <all-of>
                <assert>$result/out/@root-is-doc = "false"</assert>
                <assert>$result/out/@this-is-doc = "true"</assert>
                <assert>$result/out = "dummy"</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-82d">
        <description>Value of global context item</description>
        <created by="Michael Kay" on="2017-09-07"/>
        <environment ref="variable-with-context"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
           let $in := parse-xml("<dummy/>")
           return transform(map{
              "source-node": $in/*,
              "global-context-item": $in,
              "stylesheet-node": $stylesheet,
              "xslt-version": 3.0
           })?output
        ]]></test>
        <result>
            <all-of>
                <assert>$result/out/@root-is-doc = "true"</assert>
                <assert>$result/out/@this-is-doc = "false"</assert>
                <assert>$result/out = ""</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-82e">
        <description>Value of global context item (2.0 processor - global-context-item ignored)</description>
        <created by="Michael Kay" on="2017-09-07"/>
        <environment ref="variable-with-context"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
           let $in := parse-xml("<dummy/>")
           return transform(map{
              "source-node": $in/*,
              "global-context-item": $in/*,
              "stylesheet-node": $stylesheet,
              "xslt-version": 2.0
           })?output
        ]]></test>
        <result>
            <all-of>
                <assert>$result/out/@root-is-doc = "true"</assert>
                <assert>$result/out/@this-is-doc = "false"</assert>
                <assert>$result/out = ""</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-83">
        <description>Use initial-match-selection in place of source-node</description>
        <created by="Michael Kay" on="2018-01-12"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>let $result := fn:transform(map {"stylesheet-location" : $render, "initial-match-selection" : fn:doc($uri)})return $result?output</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-84">
        <description>Use initial-match-selection to select atomic values</description>
        <created by="Michael Kay" on="2018-01-12"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test><![CDATA[let $xsl  := "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns:xs='http://www.w3.org/2001/XMLSchema'
            version='3.0'> 
            <xsl:template match='.' as='xs:integer'>
              <xsl:sequence select='. * .'/>
            </xsl:template> 
        </xsl:stylesheet>" return
        transform(map{"stylesheet-text":$xsl,
            "delivery-format" : "raw",
            "initial-match-selection": 1 to 5
            })?output]]></test><result>
            <assert>deep-equal($result, (1, 4, 9, 16, 25))</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-err-1">
      <description>Loads a stylesheet from the location render.xsl, but fails to supply a source document</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
      <modified by="Debbie Lockett" on="2015-03-05" change="Rename stylesheet-uri as stylesheet-location; change expected error"></modified>
      <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
      <modified by="Michael Kay" on="2018-09-22" change="allow alternative error code, based on careful reading of the spec"/>
      <environment ref="works-mod-uri2"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
      <test>let $result := fn:transform(map {"stylesheet-location" : $render})return $result("output")</test>
      <result>
          <any-of>
              <error code="FOXT0002"/>
              <error code="XTDE0040"/>
          </any-of>       
      </result>
   </test-case>

     <test-case name="fn-transform-err-2">
         <description>Error test case to detect supplied parameters that are mutually exclusive (stylesheet-text and stylesheet-location)</description>
         <created by="O'Neil Delpratt" on="2014-12-09"/>
         <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
         <environment ref="works-mod-uri2"/>
      <test><![CDATA[
                    let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'
                                                                 xmlns:app='http://www.example.com'>
                                                <xsl:template name='app:main' > <xsl:for-each select='section'>
                                                <xsl:result-document href='section{position()}.html'> <!-- instructions content here -->
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>"
                    , $xml := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   </doc>"
                    return

            let $result := fn:transform(map {"stylesheet-text": $xsl,"stylesheet-location" : $render, "source-node":fn:parse-xml($xml)})return $result?output]]>
      </test>
      <result>
         <error code="FOXT0002"/>
      </result>
   </test-case>

     <test-case name="fn-transform-err-3">
      <description>Error test case to detect supplied parameters that are mutually exclusive (stylesheet-text and stylesheet-node)</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
         <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
         <environment ref="works-mod-uri2"/>
      <test><![CDATA[
                    let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'
                                                                 xmlns:app='http://www.example.com'>
                                                <xsl:template name='app:main' > <xsl:for-each select='section'>
                                                <xsl:result-document href='section{position()}.html'> <!-- instructions content here -->
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>"
                    return

            let $result := fn:transform(map {"stylesheet-text": $xsl,"stylesheet-node" : fn:doc($render), "source-node" : fn:doc($uri)})return $result?output]]>
      </test>
      <result>
         <error code="FOXT0002"/>
      </result>
   </test-case>

    <test-case name="fn-transform-err-4">
        <description>Error - the type of the value supplied for the option 'xslt-version' is incorrect</description>
        <created by="Debbie Lockett" on="2015-03-05"/>
        <modified by="Tim Mills" on="2016-10-20" change="See Bug 29944" />
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "xslt-version":"2.0" })
        ]]></test>
        <result>
            <error code="XPTY0004"/>
        </result>
    </test-case>

    <test-case name="fn-transform-err-5">
        <description>Error - the type of the value supplied for the option 'stylesheet-params' is incorrect</description>
        <created by="Debbie Lockett" on="2015-03-05"/>
        <modified by="Tim Mills" on="2016-10-20" change="See Bug 29944" />
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "stylesheet-params":"v" })
        ]]></test>
        <result>
            <error code="XPTY0004"/>
        </result>
    </test-case>

    <test-case name="fn-transform-err-6">
        <description>Error test case to detect supplied parameters that are mutually exclusive (initial-mode and initial-template)</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
            <xsl:template name='start'>
                <x><xsl:value-of select='.' /></x>
            </xsl:template>
                <xsl:template match='/' mode='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "initial-mode": fn:QName('','main'), "initial-template": fn:QName('','start') })
        ]]>
        </test>
        <result>
            <error code="FOXT0002"/>
        </result>
    </test-case>

    <test-case name="fn-transform-err-7">
        <description>Error - transform must have some options (at least one stylesheet and one source option)</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test>transform(map{})("output")</test>
        <result>
            <error code="FOXT0002"/>
        </result>
    </test-case>

    <test-case name="fn-transform-err-8">
        <description>Error - value supplied for option base-output-uri should be absolute</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2017-04-05" change="No longer an error"/>
        <modified by="Michael Kay" on="2017-05-15" change="If the value [of base-output-uri] is a relative reference, 
            it is resolved against the static base URI of the fn:transform function call"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment>
            <source role="$sbu" file="transform/staticbaseuri.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node" : $sbu, 
                                "source-node" : $sections,
                                "initial-template" : QName("", "main"),
                                "base-output-uri" : "fn/transform/output.xml", 
                                "delivery-format" : "serialized"})
                          ?*</test>
        <result>
            <assert>ends-with($result, 'fn/transform/staticbaseuri.xsl&lt;/x>')</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-err-9">
        <description>Error - transform using xsl:include with relative href, using option stylesheet-text, but without stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet version='2.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                    <xsl:include href='transform/staticbaseuri.xsl'/>
                    </xsl:stylesheet>"
            return
            fn:transform(map {"stylesheet-text" : $xsl, "initial-template" : QName('','main')})?output
            ]]></test>
        <result>
            <error code="XTSE0165"/>
        </result>
    </test-case>

    <test-case name="fn-transform-err-9a">
        <description>Error - value supplied for stylesheet-base-uri should be absolute</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <modified by="Michael Kay" on="2016-11-30" change="No longer an error : bug 30023"/>
        <modified by="Michael Kay" on="2018-09-23" change="As we were saying, this is no longer an error..."/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet version='2.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                    <xsl:include href='staticbaseuri.xsl'/>
                    </xsl:stylesheet>"
            return
            fn:transform(map {"stylesheet-text" : $xsl, "initial-template" : QName('','main'),
            "stylesheet-base-uri": "transform/include.xsl"
            })?output
            ]]></test>
        <result>
            <assert>ends-with($result/x, 'fn/transform/staticbaseuri.xsl')</assert>
        </result>
    </test-case>

    <test-case name="fn-transform-err-10">
        <description>Error - location of output documents (delivery-format serialized) undefined; no base-output-uri and xsl:result-document/@href is relative</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2016-11-30" change="Bug 29951 - delivery=saved has been dropped"/>
        <modified by="Michael Kay" on="2017-05-15" change="When no base-output-uri is supplied, the implementation may supply a default"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <modified by="Michael Kay" on="2018-09-22" change="Mismatched quotes - test was returning an unintended error"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="multiple-result-docs"/>
        <test>let $res := fn:transform(map {"stylesheet-node":$multipledocs, "source-node":$sections,
            "delivery-format":"serialized"}) return map:keys($res)[.!='output']!tokenize(., '/')[last()]</test>
        <result>
            <any-of>
                <error code="FOXT0002"/>
                <assert-permutation>"section1.html", "section2.html", "section3.html"</assert-permutation>
            </any-of>           
        </result>
    </test-case>

    <test-case name="fn-transform-err-11">
        <description>Error - location of output documents (delivery-format serialized) undefined; no base-output-uri and xsl:result-document/@href is relative</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2017-05-15" change="When no base-output-uri is supplied, the implementation may supply a default"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <modified by="Michael Kay" on="2018-09-22" change="Mismatched quotes - test was returning an unintended error"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="multiple-result-docs"/>
        <test>let $res := fn:transform(map {"stylesheet-node":$multipledocs, "source-node":$sections,
            "delivery-format":"serialized"}) return map:keys($res)[.!='output']!tokenize(., '/')[last()]</test>
        <result>
            <any-of>
                <error code="FOXT0002"/>
                <assert-permutation>"section1.html", "section2.html", "section3.html"</assert-permutation>
            </any-of> 
        </result>
    </test-case>

    <test-case name="fn-transform-err-12">
        <description>Error - location of output documents (delivery-format document) undefined; no base-output-uri and xsl:result-document/@href is relative</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <modified by="Michael Kay" on="2017-05-15" change="When no base-output-uri is supplied, the implementation may supply a default"/>
        <modified by="Michael Kay" on="2018-05-21" change="See bug 30209 regarding empty/absent principal result document"/>
        <modified by="Michael Kay" on="2018-09-22" change="Mismatched quotes - test was returning an unintended error"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="multiple-result-docs"/>
        <test>let $res := fn:transform(map {"stylesheet-node":$multipledocs, "source-node":$sections,
            "delivery-format":"document"}) return map:keys($res)[.!='output']!tokenize(., '/')[last()]</test>
        <result>
            <any-of>
                <error code="FOXT0002"/>
                <assert-permutation>"section1.html", "section2.html", "section3.html"</assert-permutation>
            </any-of> 
        </result>
    </test-case>

    <test-case name="fn-transform-err-13">
        <description>Error - value supplied for the option 'delivery-format' is not one of those allowed</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment name="multiple-result-docs2">
            <source role="$multipledocs2" file="transform/multipledocs2.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node":$multipledocs2, "source-node":$sections,
            "delivery-format":"doc"})("output")</test>
        <result>
            <error code="FOXT0002"/>
        </result>
    </test-case>

    <test-case name="fn-transform-err-14">
        <description>Error - value 'raw' supplied for the option 'delivery-format' is not allowed if processor is not XSLT 3.0</description>
        <created by="Debbie Lockett" on="2015-04-13"/>
        <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="false"/>
        <environment name="multiple-result-docs2">
            <source role="$multipledocs2" file="transform/multipledocs2.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node":$multipledocs2, "source-node":$sections,
            "delivery-format":"raw"})("output")</test>
        <result>
            <error code="FOXT0002"/>
        </result>
    </test-case>

    <test-case name="fn-transform-err-15">
        <description>Error - the initial template defines a required parameter which is not included in
            the map supplied in the XSLT 3.0 transform option template-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:template name='main'>
                <xsl:param name='param1' select='&quot;old1&quot;'/>
                <xsl:param name='param2' select='&quot;old1&quot;'/>
                <xsl:param name='param3' required='yes'/>
                    <out>
                        <xsl:value-of select='$param1' />
                        <xsl:value-of select='$param2' />
                        <xsl:value-of select='$param3' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-template": fn:QName('','main'),
            "template-params": map{QName('','param1'):"new1", QName('','param2'):"new2"}
            })
        ]]>
        </test>
        <result>
            <error code="XTDE0700"/>
        </result>
    </test-case>

    <test-case name="fn-transform-err-16">
        <description>Error - transform using XSLT 3.0 option initial-function, but without option function-params</description>
        <created by="Debbie Lockett" on="2015-04-15"/>
        <dependency type="spec" value="XQ31+"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <dependency type="feature" value="fn-transform-XSLT30" satisfied="true"/>
        <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
            xmlns:my='http://www.w3.org/fots/fn/transform/myfunctions' version='3.0'>
                <xsl:function name='my:user-function'>
                    <xsl:param name='param1'/>
                    <xsl:param name='param2'/>
                    <this>
                    <xsl:value-of select='$param1'/><xsl:value-of select='$param2'/>
                    </this>
                </xsl:function>
                <xsl:template name='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"),
            "initial-function": fn:QName('http://www.w3.org/fots/fn/transform/myfunctions','user-function')
            })
        ]]>
        </test>
        <result>
            <error code="FOXT0002"/>
        </result>
    </test-case>
    
    <test-case name="fn-transform-err-17">
        <description>Use initial-match-selection as well as source-node</description>
        <created by="Michael Kay" on="2018-01-12"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>let $result := fn:transform(map {"stylesheet-location" : $render, "initial-match-selection" : fn:doc($uri), "source-node" : fn:doc($uri)})return $result?output</test>
        <result>
            <error code="FOXT0002"/>
        </result>
    </test-case>
    
    <test-case name="fn-transform-err-18">
        <description>Stylesheet params should be supplied as QNames, not strings</description>
        <created by="Michael Kay" on="2018-01-21"/>
        <dependency type="feature" value="fn-transform-XSLT" satisfied="true" />
        <environment ref="works-mod-uri2"/>
        <test>let $result := fn:transform(map {"stylesheet-location" : $render, 
                                               "source-node" : fn:doc($uri), 
                                               "stylesheet-params" : map{ "debug": true()}
                                          }) return $result?output</test>
        <result>
            <error code="FOXT0002"/>
        </result>
    </test-case>

    <test-case name="fn-transform-901">
      <description>Loads a stylesheet from the location render.xsl, applies it to a document loaded from works-mod.xml, and uses an XPath expression to examine the result</description>
      <created by="Tim Mills" on="2016-09-07"/>
      <modified by="Abel Braaksma" on="2016-09-22" change="use function-style map lookup"/>
      <dependency type="feature" value="fn-transform-XSLT" satisfied="false"/>
      <environment ref="works-mod-uri2"/>
      <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri)})return $result("output")</test>
      <result>
            <error code="FOXT0004" />
      </result>
   </test-case>

    <test-case name="fn-transform-902">
      <description>Transform using XSLT 3.0 option static-params</description>
      <created by="Tim Mills" on="2016-09-07"/>
      <dependency type="spec" value="XQ31+"/>
      <dependency type="feature" value="fn-transform-XSLT" satisfied="false"/>
      <dependency type="feature" value="fn-transform-XSLT30" satisfied="false"/>
      <test><![CDATA[
            let $xsl  :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                <xsl:param name='static-param' static='yes' select='&quot;success&quot;'/>
                <xsl:template match='/'>
                    <out><xsl:value-of select='$static-param'/></out>
                </xsl:template>
            </xsl:stylesheet>"
            return
            transform(map{"stylesheet-node":parse-xml($xsl), "source-node":parse-xml("<doc>this</doc>"), 
            "static-params":map{QName('','static-param'):"Hello World"}
            })
        ]]></test>
      <result>
            <error code="FOXT0004" />
      </result>        
    </test-case>

</test-set>

